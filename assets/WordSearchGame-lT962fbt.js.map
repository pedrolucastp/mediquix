{"version":3,"file":"WordSearchGame-lT962fbt.js","sources":["../../src/views/WordSearchGame.vue"],"sourcesContent":["<template>\n  <GameContainer title=\"Caça-Palavras\" :gameInstructions=\"gameInstructions\" :loading=\"loading\" :score=\"score\"\n    :availablePerks=\"['hint', 'skip', 'extra_time']\" @specialty-change=\"createGame\" @difficulty-change=\"createGame\">\n   \n    <template #game-settings>\n      <div class=\"game-settings\">\n        <h3>Configurações da Grade</h3>\n        <div class=\"setting-group\">\n          <label>Tamanho da Célula (16-40px)</label>\n          <input type=\"range\" :min=\"16\" :max=\"40\" :value=\"cellSize\" @input=\"handleCellSizeChange\" />\n          <span>{{ cellSize }}px</span>\n        </div>\n        <div class=\"setting-group\">\n          <label>Largura da Grade (10-40)</label>\n          <input type=\"range\" :min=\"10\" :max=\"40\" :value=\"gridWidth\" @input=\"handleGridWidthChange\" />\n          <span>{{ gridWidth }}</span>\n        </div>\n\n        <div class=\"setting-group\">\n          <label>Altura da Grade (8-20)</label>\n          <input type=\"range\" :min=\"8\" :max=\"20\" :value=\"gridHeight\" @input=\"handleGridHeightChange\" />\n          <span>{{ gridHeight }}</span>\n        </div>\n\n      </div>\n    </template>\n\n    <div class=\"game-content\">\n      <div class=\"word-search-game-panel\" :class=\"{ 'panel-collapsed': !isWordListExpanded }\">\n        <button class=\"toggle-panel-button\" @click=\"toggleWordList\">\n          <font-awesome-icon :icon=\"isWordListExpanded ? 'chevron-up' : 'chevron-down'\" />\n          {{ isWordListExpanded ? 'Ocultar Palavras' : 'Mostrar Palavras' }}\n        </button>\n        <transition name=\"slide\">\n          <ul v-show=\"isWordListExpanded\" class=\"word-list\">\n            <li v-for=\"wordObj in gameWords\" :key=\"wordObj.word\" :title=\"wordObj.word\"\n              :class=\"{ found: foundWords.includes(wordObj.word.toUpperCase()) }\">\n              <span>{{ wordObj.clue }}</span>\n            </li>\n          </ul>\n        </transition>\n      </div>\n\n      <div class=\"game-grid-container\">\n        <div class=\"game-grid\" ref=\"gameGrid\" :style=\"gridStyle\">\n          <div v-for=\"(row, rowIndex) in grid\" :key=\"rowIndex\" class=\"grid-row\">\n            <div v-for=\"(cell, colIndex) in row\" :key=\"colIndex\" class=\"cell\" :class=\"{\n              selected: isCellSelected(rowIndex, colIndex),\n              found: isCellFound(rowIndex, colIndex),\n            }\" @click=\"handleCellClick(rowIndex, colIndex)\" :data-row=\"rowIndex\" :data-col=\"colIndex\">\n              {{ cell }}\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <p class=\"status\">{{ statusMessage }}</p>\n\n      <div v-if=\"allWordsFound\" class=\"completion-message\">\n        <h3>Parabéns!</h3>\n        <p>Você encontrou todas as palavras!</p>\n        <p>Pontos ganhos: {{ pointsEarned }}</p>\n        <BaseButton variant=\"primary\" @click=\"createGame\">Novo Jogo</BaseButton>\n      </div>\n    </div>\n  </GameContainer>\n</template>\n\n<script setup>\nimport { ref, reactive, onMounted, computed } from \"vue\";\nimport GameContainer from \"@/components/game/GameContainer.vue\";\nimport { useVocabularyStore } from \"@/store/vocabulary\";\nimport { useSettingsStore } from \"@/store/settings\";\nimport BaseButton from '@/components/base/BaseButton.vue';\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport { useGameState } from '@/composables/useGameState';\n\nconst gameInstructions = `Encontre todas as palavras escondidas na grade!\n- Clique e arraste para selecionar as palavras\n- Ganhe 2 pontos por cada palavra encontrada\n- Ganhe 10 pontos por completar o jogo\n- Ganhe 15 pontos de bônus se não errar nenhuma vez\n- Use 'hint' (5 pts) para revelar uma palavra aleatória\n- Use 'extra_time' (3 pts) para +30 segundos\n- Use 'skip' (10 pts) para gerar um novo jogo`;\n\nconst loading = ref(false);\nconst settingsStore = useSettingsStore();\nconst vocabularyStore = useVocabularyStore();\n\nconst cellSize = computed(() => settingsStore.settings.wordSearchGame.cellSize);\nconst gridWidth = computed(() => settingsStore.settings.wordSearchGame.gridWidth);\nconst gridHeight = computed(() => settingsStore.settings.wordSearchGame.gridHeight);\n\nconst gridStyle = computed(() => ({\n  display: 'grid',\n  gridTemplateColumns: `repeat(${gridHeight.value}, ${cellSize.value}px)`,\n  gridTemplateRows: `repeat(${gridWidth.value}, ${cellSize.value}px)`,\n  \"--cell-size\": `${cellSize.value}px`,\n  width: 'fit-content',\n  minWidth: 'min-content'\n}));\n\nfunction handleGridWidthChange(e) {\n  const width = parseInt(e.target.value);\n  if (width >= 10 && width <= 40) {\n    settingsStore.setWordSearchGridSize(width, gridHeight.value, cellSize.value);\n    createGame();\n  }\n}\n\nfunction handleGridHeightChange(e) {\n  const height = parseInt(e.target.value);\n  if (height >= 8 && height <= 20) {\n    settingsStore.setWordSearchGridSize(gridWidth.value, height, cellSize.value);\n    createGame();\n  }\n}\n\nfunction handleCellSizeChange(e) {\n  const size = parseInt(e.target.value);\n  if (size >= 16 && size <= 40) {\n    settingsStore.setWordSearchGridSize(gridWidth.value, gridHeight.value, size);\n  }\n}\n\nconst gameGrid = ref(null);\nconst grid = ref([]);\nconst gameWords = ref([]);\nconst foundWords = ref([]);\nconst score = ref(0);\nconst statusMessage = ref(\"\");\nconst selectedCells = ref([]);\nconst pointsEarned = ref(0);\n\nconst { POINTS_CONFIG, awardPoints, usePerk } = useGamePoints();\nconst { startGame: initGameState, endGame, resetGame } = useGameState();\n\nconst allWordsFound = computed(() => {\n  return gameWords.value.length > 0 &&\n    gameWords.value.every(word => foundWords.value.includes(word.word.toUpperCase()));\n});\n\nconst isWordListExpanded = ref(true);\n\nfunction toggleWordList() {\n  isWordListExpanded.value = !isWordListExpanded.value;\n}\n\nfunction createGame() {\n  resetGame();\n  score.value = 0;\n  statusMessage.value = \"\";\n  selectedCells.value = [];\n  foundWords.value = [];\n  foundCells = reactive({});\n\n  const rows = parseInt(gridHeight.value);\n  const cols = parseInt(gridWidth.value);\n\n  grid.value = Array(rows).fill().map(() => Array(cols).fill(\"\"));\n\n  let filteredWords = vocabularyStore.words.filter(\n    (wordObj) => wordObj.isActive\n  );\n  filteredWords = filteredWords.filter(\n    (wordObj) =>\n      wordObj.word.length <= gridWidth.value &&\n      wordObj.word.length <= gridHeight.value\n  );\n\n  if (filteredWords.length < 10) {\n    alert(\n      \"Não há palavras suficientes para iniciar o jogo. Por favor, ajuste os filtros ou adicione mais palavras que caibam na grade.\"\n    );\n    return;\n  }\n\n  const uniqueWords = Array.from(\n    new Set(filteredWords.map((wordObj) => wordObj.word.toUpperCase()))\n  );\n  if (uniqueWords.length < 10) {\n    alert(\n      \"Não há palavras únicas suficientes para iniciar o jogo. Por favor, ajuste os filtros ou adicione mais palavras.\"\n    );\n    return;\n  }\n\n  uniqueWords.sort(() => 0.5 - Math.random());\n  const selectedUnique = uniqueWords.slice(0, 10);\n  gameWords.value = selectedUnique.map((word) =>\n    filteredWords.find((wordObj) => wordObj.word.toUpperCase() === word)\n  );\n\n  let allWordsPlaced = gameWords.value.every((wordObj) => {\n    return placeWordInGrid(wordObj.word.toUpperCase());\n  });\n\n  if (!allWordsPlaced) {\n    createGame();\n    return;\n  }\n\n  fillEmptyCells();\n}\n\nfunction placeWordInGrid(word) {\n  const directions = [\"horizontal\", \"vertical\", \"diagonal-down\", \"diagonal-up\"];\n  const possibleDirections = directions.filter((direction) => {\n    const needsWidth = [\"horizontal\", \"diagonal-down\", \"diagonal-up\"].includes(direction);\n    const needsHeight = [\"vertical\", \"diagonal-down\"].includes(direction);\n    const needsInverseHeight = direction === \"diagonal-up\";\n\n    if (needsWidth && word.length > gridWidth.value) return false;\n    if (needsHeight && word.length > gridHeight.value) return false;\n    if (needsInverseHeight && word.length > gridHeight.value) return false;\n    return true;\n  });\n\n  if (possibleDirections.length === 0) {\n    console.error(`A palavra \"${word}\" é muito longa para caber na grade.`);\n    return false;\n  }\n\n  const positions = [];\n  for (const direction of possibleDirections) {\n    const maxRow = gridHeight.value - ([\"vertical\", \"diagonal-down\"].includes(direction) ? word.length : 0);\n    const minRow = direction === \"diagonal-up\" ? word.length - 1 : 0;\n    const maxCol = gridWidth.value - ([\"horizontal\", \"diagonal-down\", \"diagonal-up\"].includes(direction) ? word.length : 0);\n\n    for (let row = minRow; row < maxRow; row++) {\n      for (let col = 0; col < maxCol; col++) {\n        const posInfo = checkPosition(word, row, col, direction);\n        if (posInfo.canPlace) {\n          positions.push({\n            row,\n            col,\n            direction,\n            intersections: posInfo.intersections\n          });\n        }\n      }\n    }\n  }\n\n  positions.sort((a, b) => {\n    if (b.intersections === a.intersections) {\n      return Math.random() - 0.5;\n    }\n    return b.intersections - a.intersections;\n  });\n\n  if (positions.length > 0) {\n    const bestPos = positions[0];\n    placeWordAtPosition(word, bestPos.row, bestPos.col, bestPos.direction);\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkPosition(word, startRow, startCol, direction) {\n  let canPlace = true;\n  let intersections = 0;\n\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    const currentCell = grid.value[row][col];\n    if (currentCell !== \"\") {\n      if (currentCell !== word[i]) {\n        canPlace = false;\n        break;\n      } else {\n        intersections++;\n      }\n    }\n  }\n\n  return { canPlace, intersections };\n}\n\nfunction placeWordAtPosition(word, startRow, startCol, direction) {\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    grid.value[row][col] = word[i];\n  }\n}\n\nfunction fillEmptyCells() {\n  const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  for (let row = 0; row < gridHeight.value; row++) {\n    for (let col = 0; col < gridWidth.value; col++) {\n      if (grid.value[row][col] === \"\") {\n        grid.value[row][col] = letters.charAt(\n          Math.floor(Math.random() * letters.length)\n        );\n      }\n    }\n  }\n}\n\nfunction handleCellClick(row, col) {\n  const cellKey = `${row}-${col}`;\n  if (selectedCells.value.some((cell) => cell.key === cellKey)) {\n    selectedCells.value = selectedCells.value.filter(\n      (cell) => cell.key !== cellKey\n    );\n  } else {\n    selectedCells.value.push({ row, col, key: cellKey });\n    if (selectedCells.value.length === 2) {\n      checkSelectedWord();\n    }\n  }\n}\n\nfunction isCellSelected(row, col) {\n  if (selectedCells.value.length === 2) {\n    const [first, second] = selectedCells.value;\n    if (first.row === second.row && row === first.row) {\n      const startCol = Math.min(first.col, second.col);\n      const endCol = Math.max(first.col, second.col);\n      return col >= startCol && col <= endCol;\n    }\n    if (first.col === second.col && col === first.col) {\n      const startRow = Math.min(first.row, second.row);\n      const endRow = Math.max(first.row, second.row);\n      return row >= startRow && row <= endRow;\n    }\n  }\n  return selectedCells.value.some(\n    (cell) => cell.row === row && cell.col === col\n  );\n}\n\nlet foundCells = reactive({});\n\nfunction isCellFound(row, col) {\n  return foundCells[`${row}-${col}`] === true;\n}\n\nasync function checkSelectedWord() {\n  if (selectedCells.value.length !== 2) return;\n\n  const [first, second] = selectedCells.value;\n  const rowDiff = second.row - first.row;\n  const colDiff = second.col - first.col;\n\n  const isDiagonal = Math.abs(rowDiff) === Math.abs(colDiff);\n  const isHorizontal = rowDiff === 0;\n  const isVertical = colDiff === 0;\n\n  if (!isHorizontal && !isVertical && !isDiagonal) {\n    statusMessage.value = \"Selecione letras em linha reta (horizontal, vertical ou diagonal).\";\n    resetSelection();\n    return;\n  }\n\n  let word = \"\";\n  let cellsToCheck = [];\n\n  if (isHorizontal) {\n    const [left, right] = first.col < second.col ? [first, second] : [second, first];\n    for (let c = left.col; c <= right.col; c++) {\n      word += grid.value[left.row][c];\n      cellsToCheck.push({ row: left.row, col: c });\n    }\n  } else if (isVertical) {\n    const [top, bottom] = first.row < second.row ? [first, second] : [second, first];\n    for (let r = top.row; r <= bottom.row; r++) {\n      word += grid.value[r][top.col];\n      cellsToCheck.push({ row: r, col: top.col });\n    }\n  } else {\n    const steps = Math.abs(rowDiff);\n    const rowStep = rowDiff / steps;\n    const colStep = colDiff / steps;\n\n    for (let i = 0; i <= steps; i++) {\n      const row = first.row + (i * rowStep);\n      const col = first.col + (i * colStep);\n      word += grid.value[row][col];\n      cellsToCheck.push({ row, col });\n    }\n  }\n\n  const upperWord = word.toUpperCase();\n  const reversedWord = upperWord.split(\"\").reverse().join(\"\");\n  const foundWordObj = gameWords.value.find(\n    (wordObj) =>\n      wordObj.word.toUpperCase() === upperWord ||\n      wordObj.word.toUpperCase() === reversedWord\n  );\n\n  if (\n    foundWordObj &&\n    !foundWords.value.includes(foundWordObj.word.toUpperCase())\n  ) {\n    foundWords.value.push(foundWordObj.word.toUpperCase());\n    score.value += 10;\n    cellsToCheck.forEach((c) => {\n      foundCells[`${c.row}-${c.col}`] = true;\n    });\n    statusMessage.value = `Você encontrou: ${foundWordObj.word.toUpperCase()}`;\n    resetSelection();\n    if (foundWords.value.length === gameWords.value.length) {\n      endGame();\n      const points = calculateGamePoints();\n      await awardPoints(points);\n      pointsEarned.value = points;\n      setTimeout(() => {\n        alert(\n          `Parabéns! Você encontrou todas as palavras com ${score.value} pontos.`\n        );\n        createGame();\n      }, 500);\n    }\n  } else {\n    score.value -= 1;\n    statusMessage.value = `Palavra não encontrada: ${upperWord}`;\n    setTimeout(() => {\n      resetSelection();\n    }, 1000);\n  }\n}\n\nfunction calculateGamePoints() {\n  const basePoints = gameWords.value.length * POINTS_CONFIG.WORD_FOUND;\n  const isPerfect = score.value >= 0; // Score is only negative if there were mistakes\n  return basePoints + POINTS_CONFIG.GAME_COMPLETION + (isPerfect ? POINTS_CONFIG.PERFECT_SCORE : 0);\n}\n\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n\n  if (perkId === 'hint') {\n    const unfoundWords = gameWords.value\n      .filter(word => !foundWords.value.includes(word.word.toUpperCase()));\n    \n    if (unfoundWords.length > 0) {\n      const randomWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];\n      const cells = findWordCells(randomWord.word.toUpperCase());\n      \n      cells.forEach(cell => {\n        const el = document.querySelector(`[data-row=\"${cell.row}\"][data-col=\"${cell.col}\"]`);\n        if (el) {\n          el.classList.add('hint');\n          setTimeout(() => el.classList.remove('hint'), 2000);\n        }\n      });\n    }\n  } else if (perkId === 'skip') {\n    await createGame();\n  } else if (perkId === 'extra_time') {\n    if (typeof timeLeft !== 'undefined' && timeLeft) {\n      timeLeft.value += 30;\n    }\n  }\n}\n\nfunction findWordCells(word) {\n  const cells = [];\n  const directions = [\"horizontal\", \"vertical\", \"diagonal-down\", \"diagonal-up\"];\n  for (let row = 0; row < gridHeight.value; row++) {\n    for (let col = 0; col < gridWidth.value; col++) {\n      directions.forEach(dir => {\n        const positions = getWordPositions(word, row, col, dir);\n        if (positions.length === word.length) {\n          cells.push(...positions);\n        }\n      });\n    }\n  }\n  return cells;\n}\n\nfunction getWordPositions(word, startRow, startCol, direction) {\n  const positions = [];\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    const currentCell = grid.value[row]?.[col];\n    if (currentCell === undefined || currentCell !== word[i]) {\n      return [];\n    }\n    positions.push({ row, col });\n  }\n  return positions;\n}\n\nfunction resetSelection() {\n  selectedCells.value = [];\n}\n\nonMounted(() => {\n  createGame();\n});\n\n</script>\n\n<style scoped>\n.game-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n}\n\n.game-settings {\n  min-width: 300px;\n  padding: var(--spacing-md);\n}\n\n.game-settings h3 {\n  margin-bottom: var(--spacing-md);\n  color: var(--text-color);\n}\n\n.setting-group {\n  margin-bottom: var(--spacing-md);\n}\n\n.setting-group label {\n  display: block;\n  margin-bottom: var(--spacing-sm);\n  color: var(--text-secondary);\n}\n\n.setting-group input[type=\"range\"] {\n  width: 100%;\n}\n\n.word-search-game-panel {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  width: 100%;\n  max-width: 800px;\n  margin: 0 auto;\n  transition: all 0.3s ease;\n  z-index: 1;\n}\n\n.toggle-panel-button {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.5rem;\n  background: var(--surface-color);\n  border: 1px solid var(--border-color);\n  border-radius: var(--radius-md);\n  padding: 0.5rem 1rem;\n  color: var(--text-color);\n  font-size: 0.9rem;\n  cursor: pointer;\n  transition: all 0.2s ease;\n  width: fit-content;\n  margin: 0 auto;\n  margin-bottom: 0.5rem;\n  z-index: 2;\n}\n\n.toggle-panel-button:hover {\n  background: var(--hover-color);\n}\n\n.word-list {\n  position: relative;\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.5rem;\n  padding: 0.5rem;\n  margin: 0;\n  list-style: none;\n  width: 100%;\n  background: var(--surface-color);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-color);\n  box-shadow: var(--shadow-sm);\n  transform-origin: top center;\n}\n\n.slide-enter-active,\n.slide-leave-active {\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  max-height: 1000px;\n  opacity: 1;\n  transform: translateY(0);\n}\n\n.slide-enter-from,\n.slide-leave-to {\n  max-height: 0;\n  opacity: 0;\n  transform: translateY(-10px);\n  margin: 0;\n  padding: 0;\n}\n\n.panel-collapsed {\n  margin-bottom: 1rem;\n}\n\n.word-list li {\n  flex: 1 1 calc(33.333% - 0.5rem);\n  min-width: 150px;\n  font-size: 0.9rem;\n  color: var(--text-color);\n  text-align: left;\n  padding: 0.5rem;\n  border-radius: var(--radius-sm);\n  background-color: var(--background-color);\n  border: 1px solid var(--border-color);\n}\n\n.grid-controls {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.5rem;\n  padding: 0.5rem;\n  background-color: var(--background-color);\n  border-radius: var(--radius-md);\n}\n\n.control-group {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n  width: 100%;\n}\n\n.control-group input[type=\"range\"] {\n  width: 100%;\n  height: 6px;\n  -webkit-appearance: none;\n  appearance: none;\n  background: var(--border-color);\n  border-radius: 3px;\n  outline: none;\n  padding: 0;\n  margin: 0;\n}\n\n.control-group input[type=\"range\"]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 16px;\n  height: 16px;\n  background: var(--primary-color);\n  border-radius: 50%;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.control-group input[type=\"range\"]::-moz-range-thumb {\n  width: 16px;\n  height: 16px;\n  background: var(--primary-color);\n  border-radius: 50%;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n  border: none;\n}\n\n.control-group input[type=\"range\"]:hover::-webkit-slider-thumb {\n  background: var(--accent-color);\n}\n\n.control-group input[type=\"range\"]:hover::-moz-range-thumb {\n  background: var(--accent-color);\n}\n\n.control-group label {\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n  white-space: nowrap;\n}\n\n.game-grid-container {\n  display: flex;\n  overflow: auto;\n  width: 100%;\n  -webkit-overflow-scrolling: touch;\n  flex-wrap: wrap;\n}\n\n.game-grid {\n  display: grid;\n  background-color: var(--border-color);\n  width: fit-content;\n  margin: 20px auto;\n  border: 2px solid;\n}\n\n.cell {\n  width: var(--cell-size);\n  height: var(--cell-size);\n  background-color: var(--surface-color);\n  color: var(--text-color);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  user-select: none;\n  position: relative;\n  transition: all 0.2s ease;\n  font-weight: 600;\n  font-size: calc(var(--cell-size) * 0.6);\n  touch-action: manipulation;\n}\n\n.cell:hover {\n  background-color: var(--hover-color);\n}\n\n.cell.selected {\n  background-color: var(--accent-color);\n  color: white;\n  transform: scale(1.05);\n  z-index: 1;\n}\n\n.cell.found {\n  background-color: var(--success-color);\n  color: white;\n  border-color: var(--success-color);\n}\n\n.cell.hint {\n  animation: hint-flash 1s ease;\n}\n\n@keyframes hint-flash {\n\n  0%,\n  100% {\n    background-color: var(--surface-color);\n  }\n\n  50% {\n    background-color: var(--accent-color);\n    color: white;\n  }\n}\n\n.status {\n  margin-top: 1rem;\n  font-size: 1rem;\n  color: var(--text-color);\n  padding: 0.5rem 1rem;\n  border-radius: var(--radius-sm);\n  background-color: var(--surface-color);\n}\n\n/* .word-list {\n  display: flex;\n  gap: 0.5rem;\n  padding: 0.5rem;\n  margin: 0;\n  list-style: none;\n  width: 100%;\n  flex-direction: column;\n} */\n\n.word-list li {\n  flex: 1 1 calc(50% - 0.5rem);\n  min-width: 150px;\n  font-size: 0.9rem;\n  color: var(--text-color);\n  text-align: left;\n  padding: 0.5rem;\n  border-radius: var(--radius-sm);\n  background-color: var(--background-color);\n  border: 1px solid var(--border-color);\n}\n\n.word-list li span {\n  display: block;\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n}\n\n.word-list li.found {\n  text-decoration: line-through;\n  color: var(--accent-color);\n  background-color: rgba(var(--success-color-rgb), 0.1);\n  border-color: var(--success-color);\n}\n\n.completion-message {\n  text-align: center;\n  margin-top: var(--spacing-lg);\n  padding: var(--spacing-md);\n  background: var(--surface-color);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-color);\n}\n\n:deep(.dark) .game-container {\n  background-color: var(--dark-surface-color);\n}\n\n:deep(.dark) .word-list {\n  background-color: var(--dark-surface-color);\n}\n\n:deep(.dark) .word-list li {\n  background-color: var(--dark-background-color);\n  border-color: var(--dark-border-color);\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .word-list li span {\n  color: var(--dark-text-secondary);\n}\n\n:deep(.dark) .word-list li.found {\n  color: var(--dark-accent-color);\n  background-color: rgba(72, 187, 120, 0.1);\n  border-color: var(--dark-accent-color);\n}\n\n:deep(.dark) .cell {\n  background-color: var(--dark-surface-color);\n  border-color: var(--dark-border-color);\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .cell:hover {\n  background-color: var(--dark-hover-color);\n}\n\n:deep(.dark) .cell.selected {\n  background-color: var(--dark-accent-color);\n  color: white;\n}\n\n:deep(.dark) .cell.found {\n  background-color: var(--dark-success-color, #2F855A);\n  border-color: var(--dark-success-color, #2F855A);\n}\n\n:deep(.dark) .status {\n  color: var(--dark-text-color);\n  background-color: var(--dark-surface-color);\n}\n\n:deep(.dark) .toggle-panel-button {\n  background-color: var(--dark-surface-color);\n  border-color: var(--dark-border-color);\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .toggle-panel-button:hover {\n  background-color: var(--dark-hover-color);\n}\n\n@media (max-width: 768px) {\n  .word-search-game {\n    padding: 1rem;\n    overflow-y: auto;\n    overflow-x: hidden;\n  }\n\n  .game-container {\n    flex-direction: column;\n    padding: 1rem;\n    overflow-y: visible;\n    overflow-x: clip;\n  }\n\n  .word-search-game-panel {\n    width: 100%;\n  }\n\n  .game-grid-container {\n    overflow-y: visible;\n  }\n\n  .word-list li {\n    flex: 1 1 100%;\n    min-width: 0;\n    font-size: 1rem;\n    padding: 0.4rem;\n  }\n\n  .toggle-panel-button {\n    width: 100%;\n  }\n\n  .status {\n    font-size: 0.85rem;\n    padding: 0.4rem 0.8rem;\n  }\n}\n</style>\n"],"names":["loading","ref","settingsStore","useSettingsStore","vocabularyStore","useVocabularyStore","cellSize","computed","settings","wordSearchGame","gridWidth","gridHeight","gridStyle","display","gridTemplateColumns","value","gridTemplateRows","width","minWidth","handleGridWidthChange","e","parseInt","target","setWordSearchGridSize","createGame","handleGridHeightChange","height","handleCellSizeChange","size","gameGrid","grid","gameWords","foundWords","score","statusMessage","selectedCells","pointsEarned","POINTS_CONFIG","awardPoints","useGamePoints","endGame","resetGame","useGameState","allWordsFound","length","every","word","includes","toUpperCase","isWordListExpanded","toggleWordList","foundCells","reactive","rows","cols","Array","fill","map","filteredWords","words","filter","wordObj","isActive","alert","uniqueWords","from","Set","sort","Math","random","selectedUnique","slice","find","possibleDirections","direction","needsWidth","needsHeight","needsInverseHeight","positions","maxRow","minRow","maxCol","row","col","posInfo","checkPosition","canPlace","push","intersections","a","b","bestPos","startRow","startCol","i","placeWordAtPosition","placeWordInGrid","letters","charAt","floor","fillEmptyCells","currentCell","handleCellClick","cellKey","some","cell","key","async","first","second","rowDiff","colDiff","isDiagonal","abs","isHorizontal","isVertical","resetSelection","cellsToCheck","left","right","c","top","bottom","r","steps","rowStep","colStep","upperWord","reversedWord","split","reverse","join","foundWordObj","forEach","points","basePoints","WORD_FOUND","isPerfect","GAME_COMPLETION","PERFECT_SCORE","calculateGamePoints","setTimeout","checkSelectedWord","isCellSelected","min","endCol","max","endRow","isCellFound","onMounted"],"mappings":"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"}