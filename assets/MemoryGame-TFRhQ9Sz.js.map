{"version":3,"file":"MemoryGame-TFRhQ9Sz.js","sources":["../../src/components/game/GameCardFlip.vue","../../src/views/MemoryGame.vue"],"sourcesContent":["<template>\n  <div\n    class=\"card\"\n    :class=\"cardClasses\"\n    :style=\"cardStyles\"\n    @click=\"!disabled && emit('click')\"\n  >\n    <div class=\"card-inner\" :style=\"innerStyles\">\n      <div class=\"card-front\">\n        <slot name=\"front\">\n          <font-awesome-icon :icon=\"['fas', 'question']\" size=\"2x\" />\n        </slot>\n      </div>\n      <div class=\"card-back\">\n        <slot name=\"back\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { computed, shallowRef, watch } from 'vue';\nimport { useUIStore } from '@/store/ui';\n\nconst props = defineProps({\n  flipped: {\n    type: Boolean,\n    default: false\n  },\n  matched: {\n    type: Boolean,\n    default: false\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  }\n});\n\nconst emit = defineEmits(['click']);\n\n// Use shallowRef for better performance on frequently changing props\nconst flippedState = shallowRef(props.flipped);\nconst matchedState = shallowRef(props.matched);\n\n// Cache dark mode state\nconst uiStore = useUIStore();\nconst isDarkMode = shallowRef(uiStore.isDarkMode);\n\n// Watch props efficiently\nwatch(() => props.flipped, (newVal) => {\n  flippedState.value = newVal;\n}, { flush: 'post' });\n\nwatch(() => props.matched, (newVal) => {\n  matchedState.value = newVal;\n}, { flush: 'post' });\n\n// Cache class computation\nconst cardClasses = computed(() => ({\n  flipped: flippedState.value,\n  matched: matchedState.value,\n  dark: isDarkMode.value\n}));\n\n// Cache style computation for transforms\nconst cardStyles = computed(() => ({\n  transform: matchedState.value ? 'scale(0.95)' : undefined,\n  willChange: flippedState.value ? 'transform' : undefined\n}));\n\nconst innerStyles = computed(() => ({\n  transform: flippedState.value ? 'rotateY(180deg)' : undefined\n}));\n</script>\n\n<style scoped>\n.card {\n  aspect-ratio: 3/4;\n  perspective: 1000px;\n  cursor: pointer;\n  user-select: none;\n}\n\n.card.matched {\n  cursor: default;\n}\n\n.card-inner {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);\n  transform-style: preserve-3d;\n}\n\n.card-front,\n.card-back {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n  border-radius: var(--radius-md);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* padding: var(--spacing-md); */\n  box-shadow: var(--shadow-sm);\n  transition: all 0.3s ease;\n}\n\n.card-front {\n  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));\n  color: white;\n  font-size: 1.5rem;\n  font-weight: 600;\n}\n\n.card-back {\n  background-color: var(--surface-color);\n  border: 1px solid var(--border-color);\n  color: var(--text-color);\n  transform: rotateY(180deg) rotate(-12deg);\n  font-size: 0.9rem;\n  text-align: center;\n}\n\n/* Hover effects */\n.card:not(.matched):hover .card-front {\n  box-shadow: var(--shadow-md);\n  transform: translateZ(10px);\n}\n\n/* Dark mode styles */\n.dark .card-back {\n  background-color: var(--dark-surface-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-border-color);\n}\n\n/* Responsive styles */\n@media (max-width: 768px) {\n  .card-front {\n    font-size: 1.25rem;\n  }\n\n  .card-back {\n    font-size: 0.8rem;\n  }\n}\n</style>","<template>\n  <GameContainer\n    title=\"Jogo da Memória\"\n    :gameInstructions=\"gameInstructions\"\n    :loading=\"loading\"\n    :score=\"score\"\n    :availablePerks=\"['hint', 'open_third_card']\"\n    @specialty-change=\"createBoard\"\n    @difficulty-change=\"createBoard\"\n  >\n    <template #game-settings>\n      <div class=\"game-settings\">\n        <h3>Configurações</h3>\n        <div class=\"setting-group\">\n          <label>Número de pares</label>\n          <input type=\"range\" :value=\"pairCount\" min=\"8\" max=\"40\" step=\"4\" @input=\"handlePairCountChange\" />\n          <p class=\"setting-description\">Quantidade de pares de palavras no jogo ({{ pairCount }} pares)</p>\n        </div>\n        <!-- <div class=\"setting-group\">\n          <label>Tamanho das cartas</label>\n          <input type=\"range\" :value=\"cardSize\" min=\"100\" max=\"200\" step=\"20\" @input=\"handleCardSizeChange\" />\n          <p class=\"setting-description\">Ajuste o tamanho das cartas</p>\n        </div> -->\n      </div>\n    </template>\n\n    <div class=\"game-content\">\n      <p id=\"definition\">\n        {{\n          currentDefinition\n            ? currentDefinition.clue\n            : \"Todas as palavras foram encontradas!\"\n        }}\n      </p>\n\n      <div id=\"game-board\">\n        <GameCardFlip\n          v-for=\"(card, index) in gameCards\"\n          :key=\"index\"\n          :flipped=\"card.flipped\"\n          :matched=\"card.matched\"\n          :disabled=\"count >= maxOpenCards\"\n          :cardSize=\"cardSize\"\n          @click=\"flipCard(index)\"\n        >\n          <template #back>{{ card.word }}</template>\n        </GameCardFlip>\n      </div>\n    </div>\n  </GameContainer>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from \"vue\";\nimport GameContainer from \"@/components/game/GameContainer.vue\";\nimport GameCardFlip from \"@/components/game/GameCardFlip.vue\";\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport { useVocabularyStore } from \"@/store/vocabulary\";\n\nconst gameInstructions = `Encontre os pares de palavras correspondentes!\n- Clique em uma carta para revelar a palavra\n- Combine a palavra com sua definição mostrada acima\n- Ganhe 2 pontos por cada par encontrado\n- Ganhe 10 pontos por completar o jogo\n- Ganhe 15 pontos de bônus por terminar sem erros\n- Use o perk 'hint' (5 pts) para revelar um par de cartas\n- O perk 'open_third_card' (6 pts) permite abrir três cartas simultaneamente`;\n\nconst loading = ref(false);\nconst vocabularyStore = useVocabularyStore();\nconst { POINTS_CONFIG, awardPoints, usePerk } = useGamePoints();\n\nconst score = ref(0);\nconst attempts = ref(0);\nconst pointsEarned = ref(0);\nconst gameCards = ref([]);\nconst currentDefinition = ref(null);\nconst gameWords = ref([]);\nconst availableDefinitions = ref([]);\nconst count = ref(0);\nconst firstCardIndex = ref(null);\nconst secondCardIndex = ref(null);\nconst thirdCardIndex = ref(null);\nconst matchedCards = ref([]);\nconst maxOpenCards = ref(2);\nconst pairCount = ref(8);\nconst cardSize = ref(140);\n\nfunction handlePairCountChange(e) {\n  pairCount.value = parseInt(e.target.value);\n  createBoard();\n}\n\nfunction createBoard() {\n  score.value = 0;\n  attempts.value = 0;\n  pointsEarned.value = 0;\n  count.value = 0;\n  matchedCards.value = [];\n  maxOpenCards.value = 2;\n  firstCardIndex.value = null;\n  secondCardIndex.value = null;\n  thirdCardIndex.value = null;\n\n  let filteredWords = vocabularyStore.words.filter((word) => word.isActive);\n  if (filteredWords.length < 2) {\n    alert(\n      \"Não há palavras suficientes para iniciar o jogo. Por favor, ajuste os filtros.\"\n    );\n    return;\n  }\n\n  filteredWords.sort(() => Math.random() - 0.5);\n  gameWords.value = filteredWords.slice(0, pairCount.value);\n\n  availableDefinitions.value = [...gameWords.value];\n  selectNextDefinition();\n\n  const cards = [...gameWords.value, ...gameWords.value].map((wordObj) => ({\n    word: wordObj.word,\n    flipped: false,\n    matched: false,\n  }));\n  cards.sort(() => Math.random() - 0.5);\n  gameCards.value = cards;\n}\n\nfunction selectNextDefinition() {\n  if (availableDefinitions.value.length === 0) {\n    currentDefinition.value = null;\n  } else {\n    availableDefinitions.value.sort(() => Math.random() - 0.5);\n    currentDefinition.value = availableDefinitions.value.pop();\n  }\n}\n\nfunction flipCard(index) {\n  const card = gameCards.value[index];\n  if (card.flipped || card.matched) return;\n\n  card.flipped = true;\n  attempts.value++;\n\n  if (count.value === 0) {\n    firstCardIndex.value = index;\n    count.value = 1;\n  } else if (count.value === 1) {\n    secondCardIndex.value = index;\n    count.value = 2;\n    if (maxOpenCards.value === 2) {\n      checkMatch();\n    }\n  } else if (count.value === 2 && maxOpenCards.value === 3) {\n    thirdCardIndex.value = index;\n    count.value = 3;\n    checkMatch();\n  }\n}\n\nfunction checkMatch() {\n  const firstCard = gameCards.value[firstCardIndex.value];\n  const secondCard = gameCards.value[secondCardIndex.value];\n  \n  if (maxOpenCards.value === 2) {\n    if (\n      firstCard.word === currentDefinition.value.word &&\n      secondCard.word === currentDefinition.value.word\n    ) {\n      firstCard.matched = true;\n      secondCard.matched = true;\n      matchedCards.value.push(firstCard, secondCard);\n      resetGuesses();\n      if (matchedCards.value.length === gameCards.value.length) {\n        handleGameCompletion();\n      } else {\n        setTimeout(() => {\n          selectNextDefinition();\n        }, 500);\n      }\n    } else {\n      setTimeout(() => {\n        unflipCards();\n      }, 1000);\n    }\n  } else {\n    const thirdCard = gameCards.value[thirdCardIndex.value];\n    const word = currentDefinition.value.word;\n    let matched = 0;\n    if (firstCard.word === word) matched++;\n    if (secondCard.word === word) matched++;\n    if (thirdCard.word === word) matched++;\n    if (matched >= 2) {\n      [firstCard, secondCard, thirdCard].forEach(card => {\n        if (card.word === word) card.matched = true;\n      });\n      matchedCards.value.push(...[firstCard, secondCard, thirdCard].filter(card => card.word === word));\n      resetGuesses();\n      maxOpenCards.value = 2;\n      if (matchedCards.value.length === gameCards.value.length) {\n        handleGameCompletion();\n      } else {\n        setTimeout(() => {\n          selectNextDefinition();\n        }, 500);\n      }\n    } else {\n      setTimeout(() => {\n        unflipCards();\n        maxOpenCards.value = 2;\n      }, 1000);\n    }\n  }\n}\n\nfunction unflipCards() {\n  if (firstCardIndex.value !== null) gameCards.value[firstCardIndex.value].flipped = false;\n  if (secondCardIndex.value !== null) gameCards.value[secondCardIndex.value].flipped = false;\n  if (thirdCardIndex.value !== null) gameCards.value[thirdCardIndex.value].flipped = false;\n  resetGuesses();\n}\n\nfunction resetGuesses() {\n  count.value = 0;\n  firstCardIndex.value = null;\n  secondCardIndex.value = null;\n  thirdCardIndex.value = null;\n}\n\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n  if (perkId === 'hint' && currentDefinition.value) {\n    const word = currentDefinition.value.word;\n    const indices = gameCards.value\n      .map((card, idx) => ({ card, idx }))\n      .filter(({ card }) => card.word === word && !card.matched && !card.flipped)\n      .map(({ idx }) => idx);\n    if (indices.length >= 2) {\n      gameCards.value[indices[0]].flipped = true;\n      gameCards.value[indices[1]].flipped = true;\n      setTimeout(() => {\n        checkMatch();\n      }, 500);\n    }\n  } else if (perkId === 'open_third_card') {\n    maxOpenCards.value = 3;\n  }\n}\n\nfunction calculateGamePoints() {\n  const basePoints = (matchedCards.value.length / 2) * POINTS_CONFIG.WORD_FOUND;\n  const isPerfect = attempts.value === matchedCards.value.length;\n  return basePoints + POINTS_CONFIG.GAME_COMPLETION + (isPerfect ? POINTS_CONFIG.PERFECT_SCORE : 0);\n}\n\nasync function handleGameCompletion() {\n  const points = calculateGamePoints();\n  await awardPoints(points);\n  pointsEarned.value = points;\n  setTimeout(() => {\n    alert(\n      `Parabéns! Você encontrou todos os pares em ${attempts.value} tentativas.\\nPontos ganhos: ${points}`\n    );\n    createBoard();\n  }, 500);\n}\n\nonMounted(() => {\n  createBoard();\n});\n</script>\n\n<style scoped>\n.game-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n}\n\n.game-settings {\n  min-width: 300px;\n  padding: var(--spacing-md);\n}\n\n.game-settings h3 {\n  margin-bottom: var(--spacing-md);\n  color: var(--text-color);\n}\n\n.setting-group {\n  margin-bottom: var(--spacing-md);\n}\n\n.setting-group label {\n  display: block;\n  margin-bottom: var(--spacing-sm);\n  color: var(--text-secondary);\n  font-weight: 500;\n}\n\n.setting-description {\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xs);\n}\n\n#definition {\n  font-size: 1.25rem;\n  margin: var(--spacing-lg) 0;\n  padding: var(--spacing-md);\n  background-color: var(--surface-color);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-sm);\n  color: var(--text-color);\n  line-height: 1.6;\n  border: 1px solid var(--border-color);\n  max-width: 800px;\n  margin-left: auto;\n  margin-right: auto;\n  text-align: center;\n}\n\n#game-board {\n  display: grid;\n  grid-template-columns: repeat(8, 1fr);\n\n  gap: var(--spacing-md);\n  padding: var(--spacing-md);\n  margin: 0 auto;\n  width: 100%;\n  max-width: 900px;\n  perspective: 1000px;\n  justify-content: center;\n}\n\n@media (max-width: 768px) {\n  #game-board {\n    grid-template-columns: repeat(4, 1fr);\n  }\n}\n\n:deep(.dark) #definition {\n  background-color: var(--dark-surface-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-border-color);\n}\n\n@media (max-width: 768px) {\n  .game-content {\n    padding: var(--spacing-sm);\n  }\n\n  #game-board {\n    gap: var(--spacing-sm);\n    padding: var(--spacing-md);\n    width: 100%;\n  }\n\n  #definition {\n    font-size: 1.1rem;\n    margin: var(--spacing-md) var(--spacing-sm);\n    padding: var(--spacing-sm);\n  }\n}\n</style>\n"],"names":["props","__props","emit","__emit","flippedState","shallowRef","flipped","matchedState","matched","uiStore","useUIStore","isDarkMode","watch","newVal","value","flush","cardClasses","computed","dark","cardStyles","transform","willChange","innerStyles","loading","ref","vocabularyStore","useVocabularyStore","POINTS_CONFIG","awardPoints","useGamePoints","score","attempts","pointsEarned","gameCards","currentDefinition","gameWords","availableDefinitions","count","firstCardIndex","secondCardIndex","thirdCardIndex","matchedCards","maxOpenCards","pairCount","cardSize","handlePairCountChange","e","parseInt","target","createBoard","filteredWords","words","filter","word","isActive","length","alert","sort","Math","random","slice","selectNextDefinition","cards","map","wordObj","pop","checkMatch","firstCard","secondCard","push","resetGuesses","handleGameCompletion","setTimeout","unflipCards","thirdCard","forEach","card","async","points","basePoints","WORD_FOUND","isPerfect","GAME_COMPLETION","PERFECT_SCORE","calculateGamePoints","onMounted","index"],"mappings":"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"}