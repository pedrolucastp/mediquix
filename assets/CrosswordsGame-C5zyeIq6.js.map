{"version":3,"file":"CrosswordsGame-C5zyeIq6.js","sources":["../../src/views/CrosswordsGame.vue"],"sourcesContent":["<template>\n  <GameContainer\n    title=\"Palavras Cruzadas\"\n    :gameInstructions=\"gameInstructions\"\n    :loading=\"loading\"\n    :score=\"score\"\n    :availablePerks=\"['hint', 'extra_time', 'skip']\"\n    @specialty-change=\"startGame(true)\"\n    @difficulty-change=\"startGame(true)\"\n    @use-perk=\"handlePerk\"\n  >\n    <template #game-settings>\n      <BaseButton @click=\"startGame(true)\">Novo Jogo</BaseButton>\n      <BaseButton @click=\"revealAnswers\" variant=\"accent\">Revelar Respostas</BaseButton>\n    </template>\n\n    <div class=\"crosswords-game\">\n      <div id=\"crossword-container\">\n\n        <div id=\"crossword\" :style=\"gridStyle\">\n          <template v-for=\"row in gridRows\" :key=\"row\">\n            <div v-for=\"col in gridCols\" :key=\"`${row}-${col}`\" class=\"cell\" :class=\"{ empty: !getCell(row, col) }\"\n              :style=\"getCell(row, col) ? getHighlightedCellBorder(row, col) : {}\">\n              <template v-if=\"getCell(row, col)\">\n                <span v-if=\"isStartingCell(row, col)\" class=\"clue-number\">\n                  {{ getWordNumber(row, col) }}\n                </span>\n                <input :id=\"`cell-${row}-${col}`\" :ref=\"el => cellRefs[`${row}-${col}`] = el\" maxLength=\"1\"\n                  :data-row=\"row\" :data-col=\"col\" :data-correct=\"getCell(row, col)\" :data-words=\"getCellWords(row, col)\"\n                  :style=\"{ backgroundColor: getCellColor(row, col) }\" @input=\"handleInput\"\n                  @click=\"handleCellClick(row, col)\" />\n              </template>\n            </div>\n          </template>\n        </div>\n\n        <div id=\"clues\">\n          <ul id=\"clue-list\" :style=\"{ display: isLoading ? 'none' : 'block' }\">\n            <li v-for=\"word in placedWords\" :key=\"word.number\" :class=\"{ 'highlighted': isClueHighlighted(word.number) }\"\n              @click=\"highlightWord(word)\" :style=\"{ borderBottom: `2px solid ${word.color}` }\" :title=\"word.word\">\n              {{ word.number }}. {{ word.clue }}\n              ({{ word.direction === 'across' ? 'Horizontal' : 'Vertical' }})\n            </li>\n          </ul>\n        </div>\n      </div>\n      \n      <div v-if=\"isLoading\" class=\"loading-overlay\">\n        <div class=\"loading-message\">\n          <p>Gerando palavras cruzadas...</p>\n          <p>Tentativa {{ currentAttempt }} de {{ GAME_ATTEMPTS }}</p>\n        </div>\n      </div>\n    </div>\n  </GameContainer>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted, reactive } from 'vue'\nimport { useVocabularyStore } from '@/store/vocabulary'\nimport GameContainer from \"@/components/game/GameContainer.vue\"\nimport BaseButton from \"@/components/base/BaseButton.vue\"\nimport { useGamePoints } from '@/composables/useGamePoints'\nimport { useGameState } from '@/composables/useGameState';\n\nconst gameInstructions = `Complete as palavras cruzadas usando as dicas fornecidas.\n- Clique em uma célula para selecionar uma palavra\n- Use as dicas para descobrir as palavras\n- Ganhe 2 pontos por cada palavra completada\n- Ganhe 10 pontos por completar o jogo\n- Ganhe 15 pontos de bônus por terminar sem erros\n- Use a dica (5 pts) para revelar uma letra aleatória\n- Todas as palavras estão relacionadas à especialidade médica selecionada`\n\nconst { usePerk, POINTS_CONFIG, awardPoints } = useGamePoints();\nconst { startGame: initGameState, endGame, resetGame } = useGameState();\n\n// Constants\nconst PLACEMENT_DELAY = 20; // 500ms delay between attempts\nconst GAME_ATTEMPTS = 5;\nconst WORD_COUNT = 5\nconst GRID_ROWS = 25\nconst GRID_COLS = 30\nconst WORD_COLORS = [\n  '#FF6B6B', // coral red\n  '#4ECDC4', // turquoise\n  '#45B7D1', // sky blue\n  '#96CEB4', // sage green\n  '#ff24c0', // pink\n  '#D4A5A5', // dusty rose\n  '#9B97B2', // muted purple\n  '#FFB347', // pastel orange\n  '#87CEEB', // light blue\n  '#98FB98'  // pale green\n]\nconst GRID_CENTER_ROW = Math.floor(GRID_ROWS / 2)\nconst GRID_CENTER_COL = Math.floor(GRID_COLS / 2)\n\n// Refs\nconst grid = ref([])\nconst placedWords = ref([])\nconst currentWord = ref(null)\nconst currentDirection = ref('across')\nconst highlightedCells = ref(new Set())\nconst highlightedIntersections = ref(new Set())\nconst highlightedClue = ref(null)\nconst cellRefs = reactive({})\nconst isLoading = ref(false)\nconst currentAttempt = ref(1)\nconst loading = ref(false)\nconst score = ref(0)\nconst gameStarted = ref(false)\nconst pointsEarned = ref(0)\n\n// Stores\nconst vocabularyStore = useVocabularyStore()\n\n// Add a flag to track initial load\nconst isInitialLoad = ref(true)\n\n// Add to the refs section\nconst lastClickedCell = ref({ row: null, col: null, wordIndex: 0 })\n\n// Computed\nconst gridStyle = computed(() => ({\n  gridTemplateColumns: `repeat(${GRID_COLS}, 40px)`,\n  gridTemplateRows: `repeat(${GRID_ROWS}, 40px)`\n}))\n\nconst gridRows = computed(() => Array.from({ length: GRID_ROWS }, (_, i) => i))\nconst gridCols = computed(() => Array.from({ length: GRID_COLS }, (_, i) => i))\n\n// Methods\nfunction getCell(row, col) {\n  return grid.value[row]?.[col] || null\n}\n\nfunction getCellWords(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return JSON.stringify(cellWords.map(word => ({\n    wordNumber: word.number,\n    direction: word.direction\n  })))\n}\n\nfunction getCellColor(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return cellWords.length > 0 ? getCell(row, col) === ' ' ? 'white' : cellWords[0].color + ((isHighlighted(row, col) || isIntersectionHighlighted(row, col)) ? '' : '70') : 'transparent';\n}\n\n//Function to help to determine the border of a highlited cell when a word is selected, apply a 3px solid darkgrey;\n// when the word is in horizontal direction, \n// all cells of the current selected word should have border on top and bottom;\n// the first cell should also have border on left;\n// the last  cell should also have border on right; \n\n// when the word is in vertical direction,\n// all cells of the current selected word should have border on left and right;\n// the first cell should also have border on top;\n// the last cell should also have border on bottom;\n\nfunction getHighlightedCellBorder(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n\n  if (cellWords.length === 0) return {}\n\n  // Initialize styles with default border\n  const styles = {\n    border: '1px solid var(--dark-border-color)',\n    backgroundColor: 'transparent'\n  }\n\n  // Find which word is currently highlighted (if any)\n  const highlightedWord = cellWords.find(word => \n    word.positions.some(pos => highlightedCells.value.has(`${pos.row}-${pos.col}`))\n  )\n\n  if (highlightedWord) {\n    styles.backgroundColor = 'rgba(255, 255, 0, 0.1)'\n\n    // Get the cell's position within the highlighted word\n    const cellIndex = highlightedWord.positions.findIndex(pos => pos.row === row && pos.col === col)\n    const isFirstCell = cellIndex === 0\n    const isLastCell = cellIndex === highlightedWord.positions.length - 1\n\n    if (highlightedWord.direction === 'across') {\n      styles.borderTop = '3px solid darkgrey'\n      styles.borderBottom = '3px solid darkgrey'\n      if (isFirstCell) styles.borderLeft = '3px solid darkgrey'\n      if (isLastCell) styles.borderRight = '3px solid darkgrey'\n    } else { // direction is 'down'\n      styles.borderLeft = '3px solid darkgrey'\n      styles.borderRight = '3px solid darkgrey'\n      if (isFirstCell) styles.borderTop = '3px solid darkgrey'\n      if (isLastCell) styles.borderBottom = '3px solid darkgrey'\n    }\n  }\n\n  return styles\n}\n\nfunction isStartingCell(row, col) {\n  return placedWords.value.some(word => {\n    if (word.row === row && word.col === col) {\n      return true;\n    }\n    return false;\n  })\n}\n\nfunction getWordNumber(row, col) {\n  const word = placedWords.value.find(w => w.row === row && w.col === col)\n  return word?.number\n}\n\nfunction isHighlighted(row, col) {\n  return highlightedCells.value.has(`${row}-${col}`)\n}\n\nfunction isIntersectionHighlighted(row, col) {\n  return highlightedIntersections.value.has(`${row}-${col}`)\n}\n\nfunction isClueHighlighted(number) {\n  return highlightedClue.value === number\n}\n\nfunction highlightWord(wordObj) {\n  clearHighlights()\n\n  wordObj.positions.forEach(pos => {\n    highlightedCells.value.add(`${pos.row}-${pos.col}`)\n  })\n\n  highlightedClue.value = wordObj.number\n}\n\nfunction handleCellClick(row, col) {\n  const cellWords = JSON.parse(getCellWords(row, col))\n  if (cellWords.length === 0) return\n\n  // Reset word index if clicking a different cell\n  if (lastClickedCell.value.row !== row || lastClickedCell.value.col !== col) {\n    lastClickedCell.value = { row, col, wordIndex: 0 }\n  } else {\n    // Cycle through words at the same cell\n    lastClickedCell.value.wordIndex = (lastClickedCell.value.wordIndex + 1) % cellWords.length\n  }\n\n  const selectedWord = placedWords.value.find(w =>\n    w.number === cellWords[lastClickedCell.value.wordIndex].wordNumber\n  )\n\n  if (selectedWord) {\n    highlightWord(selectedWord)\n    const input = cellRefs[`${row}-${col}`]\n    if (input) {\n      input.select()\n    }\n  }\n}\n\nfunction clearHighlights() {\n  highlightedCells.value.clear()\n  highlightedIntersections.value.clear()\n  highlightedClue.value = null\n}\n\nfunction normalizeString(str) {\n  return str.normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toUpperCase()\n    .trim()\n}\n\nfunction handleInput(event) {\n  const input = event.target\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n\n  // Set direction and highlight word if needed\n  if (cellWords && cellWords.length > 0 && (!currentWord.value || !isInputPartOfCurrentWord(input))) {\n    currentWord.value = cellWords[0]\n    currentDirection.value = cellWords[0].direction\n    const word = placedWords.value.find(w => w.number === cellWords[0].wordNumber)\n    if (word) {\n      highlightWord(word)\n    }\n  }\n\n  // Handle backspace (when input becomes empty or no data event)\n  if (!event.data || input.value === '') {\n    input.value = '' // Ensure the current cell is empty\n    moveToPreviousInput(input)\n    return\n  }\n\n  // Handle normal typing (overwrite mode)\n\n  input.value = event.data.toUpperCase()\n  input.select()\n  moveToNextInput(input)\n}\n\nfunction moveToNextInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let nextRow = currentRow\n  let nextCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    nextCol++\n  } else {\n    nextRow++\n  }\n\n  const nextInput = cellRefs[`${nextRow}-${nextCol}`]\n  if (nextInput && isInputPartOfCurrentWord(nextInput)) {\n    nextInput.focus()\n  }\n}\n\nfunction moveToPreviousInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let prevRow = currentRow\n  let prevCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    prevCol--\n  } else {\n    prevRow--\n  }\n\n  const prevInput = cellRefs[`${prevRow}-${prevCol}`]\n  if (prevInput && isInputPartOfCurrentWord(prevInput)) {\n    prevInput.focus()\n    prevInput.select() // Select text in previous cell\n  }\n}\n\nfunction isInputPartOfCurrentWord(input) {\n  if (!currentWord.value || !currentDirection.value) return false;\n\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n  if (!cellWords || cellWords.length === 0) return false;\n\n  // Check if any word in this cell matches our current direction and is part of our path\n  const currentWordObj = placedWords.value.find(w => w.number === currentWord.value.wordNumber);\n  if (!currentWordObj) return false;\n\n  // Get the input's position\n  const row = parseInt(input.dataset.row);\n  const col = parseInt(input.dataset.col);\n\n  // Check if this position is part of our current word's path\n  if (currentDirection.value === 'across') {\n    return row === currentWordObj.row &&\n      col >= currentWordObj.col &&\n      col < currentWordObj.col + currentWordObj.word.length;\n  } else {\n    return col === currentWordObj.col &&\n      row >= currentWordObj.row &&\n      row < currentWordObj.row + currentWordObj.word.length;\n  }\n}\n\nfunction calculateGamePoints(mistakes) {\n  const basePoints = WORD_COUNT * POINTS_CONFIG.WORD_FOUND;\n  const isPerfect = mistakes === 0;\n  return basePoints + POINTS_CONFIG.GAME_COMPLETION + (isPerfect ? POINTS_CONFIG.PERFECT_SCORE : 0);\n}\n\nasync function handleGameCompletion(mistakes = 0) {\n  endGame();\n  const points = calculateGamePoints(mistakes);\n  await awardPoints(points);\n  pointsEarned.value = points;\n  alert(`Parabéns! Você completou o jogo${mistakes === 0 ? ' sem erros' : ''}!\\nPontos ganhos: ${points}`);\n}\n\nfunction initializeGrid() {\n  // Clear the grid array\n  grid.value = []\n  for (let i = 0; i < GRID_ROWS; i++) {\n    grid.value.push(new Array(GRID_COLS).fill(null))\n  }\n\n  // Clear all input values and styling\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    if (input) {\n      input.value = ''\n      input.style.backgroundColor = 'transparent'\n      input.style.color = 'var(--text-color)'\n    }\n  }\n\n  // Clear placed words and highlights\n  placedWords.value = []\n  clearHighlights()\n\n  // Reset any game state\n  currentWord.value = null\n  currentDirection.value = 'across'\n\n  grid.value.forEach(row => row.fill(null));\n}\n\n\nfunction canPlaceWord(word, row, col, direction) {\n  if (direction === 'across') {\n    if (col < 0 || col + word.length > GRID_COLS || row < 0 || row >= GRID_ROWS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row][col + i];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const above = row > 0 ? grid.value[row - 1][col + i] : null;\n      const below = row < GRID_ROWS - 1 ? grid.value[row + 1][col + i] : null;\n\n      if ((above && !isPartOfWord(row - 1, col + i)) ||\n        (below && !isPartOfWord(row + 1, col + i))) {\n        return false;\n      }\n    }\n\n    const before = col > 0 ? grid.value[row][col - 1] : null;\n    const after = col + word.length < GRID_COLS ? grid.value[row][col + word.length] : null;\n    if (before || after) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n\n  } else if (direction === 'down') {\n    if (row < 0 || row + word.length > GRID_ROWS || col < 0 || col >= GRID_COLS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row + i][col];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const left = col > 0 ? grid.value[row + i][col - 1] : null;\n      const right = col < GRID_COLS - 1 ? grid.value[row + i][col + 1] : null;\n\n      if ((left && !isPartOfWord(row + i, col - 1)) ||\n        (right && !isPartOfWord(row + i, col + 1))) {\n        return false;\n      }\n    }\n\n    const above = row > 0 ? grid.value[row - 1][col] : null;\n    const below = row + word.length < GRID_ROWS ? grid.value[row + word.length][col] : null;\n    if (above || below) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n  }\n  return false;\n}\n\nfunction isPartOfWord(row, col) {\n  return placedWords.value.some(wordObj => {\n    if (wordObj.direction === 'across') {\n      return row === wordObj.row && col >= wordObj.col && col < wordObj.col + wordObj.word.length\n    } else if (wordObj.direction === 'down') {\n      return col === wordObj.col && row >= wordObj.row && row < wordObj.row + wordObj.word.length\n    }\n    return false\n  })\n}\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function visualizePlacement(word, row, col, direction, temp = true) {\n  const positions = [];\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] === null) {\n        grid.value[row][col + i] = temp ? '?' : word[i];\n        positions.push({ row, col: col + i });\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] === null) {\n        grid.value[row + i][col] = temp ? '?' : word[i];\n        positions.push({ row: row + i, col });\n      }\n    }\n  }\n\n  if (temp) {\n    await sleep(PLACEMENT_DELAY);\n    positions.forEach(pos => {\n      if (grid.value[pos.row][pos.col] === '?') {\n        grid.value[pos.row][pos.col] = null;\n      }\n    });\n  }\n  return positions;\n}\n\nfunction countIntersections(word, row, col, direction) {\n  let intersections = 0;\n\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] !== null && grid.value[row][col + i] === word[i]) {\n        intersections++;\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] !== null && grid.value[row + i][col] === word[i]) {\n        intersections++;\n      }\n    }\n  }\n\n  return intersections;\n}\n\nfunction findAllPossiblePositions(word, direction) {\n  const positions = [];\n\n  for (let row = 0; row < GRID_ROWS; row++) {\n    for (let col = 0; col < GRID_COLS; col++) {\n      if (canPlaceWord(word, row, col, direction)) {\n        const intersections = countIntersections(word, row, col, direction);\n        positions.push({\n          row,\n          col,\n          direction,\n          intersections\n        });\n      }\n    }\n  }\n\n  // Sort by number of intersections in descending order\n  positions.sort((a, b) => b.intersections - a.intersections);\n\n  return positions;\n}\n\nasync function placeRemainingWords(availableWords) {\n\n  while (placedWords.value.length < WORD_COUNT) {\n    let placed = false;\n    const triedIndices = new Set();\n\n    // Keep trying random words until we place one or exhaust all options\n    while (!placed && triedIndices.size < availableWords.length) {\n      let randomIndex;\n      do {\n        randomIndex = Math.floor(Math.random() * availableWords.length);\n      } while (triedIndices.has(randomIndex));\n\n      triedIndices.add(randomIndex);\n      const word = availableWords[randomIndex];\n      const allPossiblePositions = [];\n\n      // Find all possible positions in both directions\n      for (const direction of ['across', 'down']) {\n        const positionsInDirection = await findAllPossiblePositions(word.word, direction);\n        allPossiblePositions.push(...positionsInDirection);\n      }\n\n      // If we found valid positions\n      if (allPossiblePositions.length > 0) {\n        // Sort by intersections\n        allPossiblePositions.sort((a, b) => b.intersections - a.intersections);\n\n        // Take top 3 positions when available\n        const topPositions = allPossiblePositions.slice(0, Math.min(3, allPossiblePositions.length));\n\n        // Randomly select from top positions\n        const selectedPosition = topPositions[Math.floor(Math.random() * topPositions.length)];\n\n        // Visualize the attempt\n        await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, true);\n\n        // Place the word\n        const positions = await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, false);\n\n        if (positions.length > 0) {\n          placedWords.value.push({\n            word: word.word,\n            clue: word.clue,\n            row: selectedPosition.row,\n            col: selectedPosition.col,\n            direction: selectedPosition.direction,\n            positions: positions,\n            number: placedWords.value.length + 1,\n\n            // Assign a color based on the amount of available colors.\n            // color: WORD_COLORS[placedWords.value.length]\n            color: WORD_COLORS[placedWords.value.length % WORD_COLORS.length]\n          });\n          availableWords.splice(randomIndex, 1);\n          placed = true;\n          break;\n        }\n      }\n    }\n\n    if (!placed) {\n      console.log('No more words can be placed with current configuration');\n      return false;\n    }\n  }\n\n  return placedWords.value.length === WORD_COUNT;\n}\n\nasync function generateCrossword(words) {\n  if (currentAttempt.value > GAME_ATTEMPTS) {\n    console.log('Maximum attempts reached');\n    return false;\n  }\n\n  console.log(`Attempt ${currentAttempt.value} of 10`);\n  initializeGrid();\n  setTimeout(() => scrollToGridCenter(), 100)\n\n\n  // Create a copy of words array to work with\n  const availableWords = [...words];\n  const triedIndices = new Set();\n\n  // Try to place first word\n  while (triedIndices.size < availableWords.length) {\n    let randomIndex;\n    do {\n      randomIndex = Math.floor(Math.random() * availableWords.length);\n\n    } while (triedIndices.has(randomIndex));\n\n    triedIndices.add(randomIndex);\n    const firstWord = availableWords[randomIndex];\n\n    // Try to place the first word horizontally in the center\n    const positions = await visualizePlacement(\n      firstWord.word,\n      GRID_CENTER_ROW,\n      Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n      'across',\n      false\n    );\n\n    if (positions.length > 0) {\n      placedWords.value.push({\n        word: firstWord.word,\n        clue: firstWord.clue,\n        row: GRID_CENTER_ROW,\n        col: Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n        direction: 'across',\n        positions: positions,\n        number: 1,\n        color: WORD_COLORS[0]\n      });\n\n      availableWords.splice(randomIndex, 1);\n\n      // Try to place remaining words with the new strategy\n      const success = await placeRemainingWords(availableWords);\n      if (success) {\n        return true;\n      }\n    }\n  }\n\n  currentAttempt.value++;\n  return false;\n}\n\nfunction scrollToGridCenter() {\n  const crosswordDiv = document.getElementById('crossword')\n  if (crosswordDiv) {\n    const scrollLeft = (crosswordDiv.scrollWidth - crosswordDiv.clientWidth) / 2\n    const scrollTop = (crosswordDiv.scrollHeight - crosswordDiv.clientHeight) / 2\n    crosswordDiv.scrollTo({\n      left: scrollLeft,\n      top: scrollTop,\n      behavior: 'smooth'\n    })\n  }\n}\n\nasync function startGame(force = false) {\n  resetGame();\n  loading.value = true;\n  isLoading.value = true;\n  \n  try {\n    // Initialize game state\n    if (!initGameState()) {\n      throw new Error('Failed to initialize game state');\n    }\n    \n    const words = vocabularyStore.filteredWords\n    const success = await generateCrossword(words)\n\n    if (!success && currentAttempt.value < GAME_ATTEMPTS) {\n      await startGame(true)\n    }\n  } catch (error) {\n    console.error('Error generating crossword:', error)\n  } finally {\n    isLoading.value = false\n    loading.value = false\n    clearHighlights()\n    isInitialLoad.value = false\n  }\n}\n\n/**\n * @function handlePerk\n * @param {string} perkId - The perk to activate\n * @returns {Promise<void>}\n * @description Deducts points and applies the perk effect. 'hint' reveals a random letter in the grid.\n */\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n\n  if (perkId === 'hint') {\n    // Reveal a random letter in the crossword grid\n    const allInputs = Object.values(cellRefs).filter(input => \n      input && \n      input.value === '' && \n      input.dataset.letter\n    );\n    \n    if (allInputs.length > 0) {\n      const randomInput = allInputs[Math.floor(Math.random() * allInputs.length)];\n      const letter = randomInput.dataset.letter;\n      randomInput.value = letter;\n      randomInput.classList.add('revealed');\n      checkWord(randomInput);\n    }\n  } else if (perkId === 'skip') {\n    // Skip current grid and generate a new one\n    await startGame(true);\n  } else if (perkId === 'extra_time') {\n    // Add 30 seconds to the timer if it exists\n    if (typeof timeLeft !== 'undefined' && timeLeft) {\n      timeLeft.value += 30;\n    }\n  }\n}\n\n/**\n * @function revealAnswers\n * @description Reveals all answers in the crossword grid and updates the score to 0.\n */\nfunction revealAnswers() {\n  // Reveal all answers and mark them in red\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    if (input && input.dataset.correct) {\n      input.value = input.dataset.correct\n      input.style.color = '#FF0000'\n    }\n  }\n  // Update the score to 0 since answers were revealed\n  score.value = 0\n}\n\n// Initialization\nonMounted(() => {\n  startGame()\n})\n</script>\n\n<style scoped>\n#crossword-container {\n  display: flex;\n  justify-content: center;\n  align-items: flex-start;\n  gap: var(--spacing-lg, 2rem);\n  padding: var(--spacing-md, 1rem);\n  max-width: 1400px;\n  margin: 0 auto;\n  width: 100%;\n  min-height: calc(100vh - 200px);\n  position: relative;\n}\n\n.crosswords-game {\n  touch-action: none;\n  /* Prevent zooming on the page */\n  -ms-content-zooming: none;\n  -ms-touch-action: none;\n}\n\n#clues {\n  position: absolute;\n  top: var(--spacing-md, 1rem);\n  left: var(--spacing-md, 1rem);\n  width: 350px;\n  flex-shrink: 0;\n  padding: var(--spacing-md, 1rem);\n  border-radius: var(--radius-md, 8px);\n  box-shadow: var(--shadow-sm);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  max-height: 80vh;\n}\n\n\n#crossword {\n  display: grid;\n  gap: 0;\n  margin: 0;\n  padding: 2rem 2rem 2rem 350px;\n  /* border-radius: var(--radius-md); */\n  box-shadow: var(--shadow-md);\n  overflow: auto;\n  max-height: 80vh;\n  border: 2px solid var(--dark-border-color);\n  touch-action: manipulation;\n  -webkit-overflow-scrolling: touch;\n  -webkit-user-select: none;\n  user-select: none;\n  transform: scale(1);\n  transform-origin: center;\n  touch-action: pan-x pan-y pinch-zoom;\n  width: 100%;\n  position: relative;\n}\n\n/* Scrollbar styling */\n::-webkit-scrollbar {\n  width: 3px;\n  height: 3px;\n}\n\n::-webkit-scrollbar-track {\n  background: transparent;\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb {\n  background: var(--primary-color);\n\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: var(--accent-color);\n}\n\n@media (max-width: 768px) {\n  #crossword-container {\n    flex-direction: column;\n    align-items: center;\n    padding: 20px 0;\n  }\n\n  #crossword {\n    width: 90%;\n    order: 2;\n    padding: 10px;\n  }\n\n  #clues {\n    width: 100%;\n    position: relative;\n    top: 0;\n    left: 0;\n    order: 1;\n    max-height: none;\n  }\n}\n\n.cell {\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* Remove the default border since we handle it in getHighlightedCellBorder */\n  /* border: 1px solid var(--dark-border-color); */\n}\n\n.empty {\n  border: none;\n  background-color: transparent;\n}\n\n.cell input {\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  font-size: 16px;\n  padding: 0;\n  margin: 0;\n  border: none;\n  outline: none;\n  background: transparent;\n  text-transform: uppercase;\n  box-sizing: border-box;\n  border-radius: 0;\n}\n\n.cell:hover {\n  background-color: var(--hover-color, rgba(0, 0, 0, 0.05));\n}\n\n.cell input:focus {\n  background-color: var(--focus-color, rgba(var(--primary-rgb, 46, 204, 113), 0.1));\n}\n\n.cell input.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n.cell input.highlighted-intersection {\n  background-color: var(--intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n.cell .clue-number {\n  position: relative;\n  top: -8px;\n  left: 2px;\n  font-size: var(--clue-number-size, 0.75rem);\n  font-weight: bold;\n  color: var(--text-color);\n  width: 0;\n}\n\n/* #clues h2 {\n  font-size: 24px;\n  margin-bottom: 10px;\n  color: var(--text-color);\n} */\n\n#clue-list {\n  list-style: none;\n  margin-top: 20px;\n  overflow-y: auto;\n  list-style-position: outside;\n}\n\n#clue-list li {\n  margin-bottom: 0px;\n  font-size: 1rem;\n  text-align: left;\n  /* color: #eee; */\n  word-wrap: break-word;\n  cursor: pointer;\n  padding: 4px;\n}\n\n#clue-list li.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n  font-size: 1.1rem;\n}\n\n.button-container {\n  display: none;\n}\n\n@media (max-width: 480px) {\n  .cell {\n    width: 100%;\n    height: 100%;\n  }\n\n  .cell input {\n    font-size: 14px;\n  }\n}\n\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(255, 255, 255, 0.4);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 100;\n}\n\n.loading-message {\n  text-align: center;\n  padding: 20px;\n  background-color: var(--surface-color, #fff);\n  border-radius: 8px;\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--border-color);\n}\n\n:deep(.dark) .loading-overlay {\n  background: rgba(0, 0, 0, 0.4);\n}\n\n:deep(.dark) .cell {\n  border-color: var(--dark-border-color);\n}\n\n:deep(.dark) .cell:hover {\n  background-color: var(--dark-hover-color, rgba(255, 255, 255, 0.1));\n}\n\n:deep(.dark) .cell input {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .cell input:focus {\n  background-color: var(--dark-focus-color, rgba(var(--dark-primary-rgb, 46, 204, 113), 0.2));\n}\n\n:deep(.dark) .cell input.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n:deep(.dark) .cell input.highlighted-intersection {\n  background-color: var(--dark-intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n:deep(.dark) .cell .clue-number {\n  color: var(--dark-text-color);\n}\n\n/* :deep(.dark) #clues h2 {\n  color: var(--dark-text-color);\n} */\n\n:deep(.dark) #clue-list li {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) #clue-list li.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n</style>"],"names":["GRID_ROWS","GRID_COLS","usePerk","useGamePoints","startGame","initGameState","resetGame","useGameState","WORD_COLORS","GRID_CENTER_ROW","Math","floor","GRID_CENTER_COL","grid","ref","placedWords","currentWord","currentDirection","highlightedCells","Set","highlightedIntersections","highlightedClue","cellRefs","reactive","isLoading","currentAttempt","loading","score","vocabularyStore","useVocabularyStore","isInitialLoad","lastClickedCell","row","col","wordIndex","gridStyle","computed","gridTemplateColumns","gridTemplateRows","gridRows","Array","from","length","_","i","gridCols","getCell","_a","value","getCellWords","cellWords","filter","word","positions","some","pos","JSON","stringify","map","wordNumber","number","direction","getCellColor","color","has","isHighlighted","isIntersectionHighlighted","getHighlightedCellBorder","styles","border","backgroundColor","highlightedWord","find","cellIndex","findIndex","isFirstCell","isLastCell","borderTop","borderBottom","borderLeft","borderRight","isStartingCell","getWordNumber","w","highlightWord","wordObj","clearHighlights","forEach","add","clear","handleInput","event","input","target","parse","dataset","words","isInputPartOfCurrentWord","data","currentInput","currentRow","parseInt","currentCol","prevRow","prevCol","prevInput","focus","select","moveToPreviousInput","toUpperCase","nextRow","nextCol","nextInput","moveToNextInput","currentWordObj","canPlaceWord","hasIntersection","currentCell","above","below","isPartOfWord","before","after","left","right","async","visualizePlacement","temp","push","ms","Promise","resolve","setTimeout","sleep","countIntersections","intersections","findAllPossiblePositions","sort","a","b","placeRemainingWords","availableWords","placed","triedIndices","size","randomIndex","random","allPossiblePositions","positionsInDirection","topPositions","slice","min","selectedPosition","clue","splice","generateCrossword","fill","key","style","initializeGrid","crosswordDiv","document","getElementById","scrollLeft","scrollWidth","clientWidth","scrollTop","scrollHeight","clientHeight","scrollTo","top","behavior","scrollToGridCenter","firstWord","force","Error","filteredWords","error","handlePerk","perkId","allInputs","Object","values","letter","randomInput","classList","checkWord","timeLeft","revealAnswers","correct","onMounted","selectedWord"],"mappings":"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"}