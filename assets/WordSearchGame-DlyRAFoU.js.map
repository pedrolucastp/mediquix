{"version":3,"file":"WordSearchGame-DlyRAFoU.js","sources":["../../src/views/WordSearchGame.vue"],"sourcesContent":["<template>\n  <div class=\"word-search-game\">\n    <h1>Caça-Palavras</h1>\n    <SelectorsComponent @specialty-change=\"createGame\" @difficulty-change=\"createGame\" />\n\n    <GamePerksMenu :availablePerks=\"['hint']\" @perk-activated=\"handlePerk\" />\n\n    <div class=\"game-container\">\n      <!-- Word list moved before grid for better mobile flow -->\n      <div class=\"word-search-game-panel\">\n        <ul class=\"word-list\">\n          <li v-for=\"wordObj in gameWords\" :key=\"wordObj.word\" :title=\"wordObj.word\"\n            :class=\"{ found: foundWords.includes(wordObj.word.toUpperCase()) }\">\n            <span>{{ wordObj.clue }}</span>\n          </li>\n        </ul>\n\n      </div>\n\n      <div class=\"game-grid-container\">\n\n        <div class=\"game-grid\" ref=\"gameGrid\" :style=\"gridStyle\">\n          <div v-for=\"(row, rowIndex) in grid\" :key=\"rowIndex\" class=\"grid-row\">\n            <div v-for=\"(cell, colIndex) in row\" :key=\"colIndex\" class=\"cell\" :class=\"{\n              selected: isCellSelected(rowIndex, colIndex),\n              found: isCellFound(rowIndex, colIndex),\n            }\" @click=\"handleCellClick(rowIndex, colIndex)\" :data-row=\"rowIndex\" :data-col=\"colIndex\">\n              {{ cell }}\n            </div>\n          </div>\n        </div>\n      </div>\n      \n    </div>\n    <div class=\"grid-controls\">\n        <div class=\"control-group\">\n          <label>Altura da grade: {{ gridWidth }}</label>\n          <input type=\"range\" :value=\"gridWidth\" min=\"10\" max=\"40\" step=\"1\" @input=\"handleGridWidthChange\" />\n        </div>\n        <div class=\"control-group\">\n          <label>Largura da grade: {{ gridHeight }}</label>\n          <input type=\"range\" :value=\"gridHeight\" min=\"8\" max=\"20\" step=\"1\" @input=\"handleGridHeightChange\" />\n        </div>\n        <div class=\"control-group\">\n          <label>Tamanho da célula: {{ cellSize }}</label>\n          <input type=\"range\" :value=\"cellSize\" min=\"16\" max=\"40\" step=\"2\" @input=\"handleCellSizeChange\" />\n        </div>\n      </div>\n    <p class=\"status\">{{ statusMessage }}</p>\n\n    <div v-if=\"allWordsFound\" class=\"completion-message\">\n      <h3>Parabéns!</h3>\n      <p>Você encontrou todas as palavras!</p>\n      <p>Pontos ganhos: {{ pointsEarned }}</p>\n      <BaseButton variant=\"primary\" @click=\"createGame\">Novo Jogo</BaseButton>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, reactive, onMounted, computed } from \"vue\";\nimport { useVocabularyStore } from \"@/store/vocabulary\";\nimport { useSettingsStore } from \"@/store/settings\";\nimport SelectorsComponent from \"@/components/SelectorsComponent.vue\";\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport GamePerksMenu from '../components/game/GamePerksMenu.vue';\nimport BaseButton from '@/components/base/BaseButton.vue';\n\nconst settingsStore = useSettingsStore();\nconst vocabularyStore = useVocabularyStore();\n\nconst cellSize = computed(() => settingsStore.settings.wordSearchGame.cellSize);\nconst gridWidth = computed(() => settingsStore.settings.wordSearchGame.gridWidth);\nconst gridHeight = computed(() => settingsStore.settings.wordSearchGame.gridHeight);\n\nconst gridStyle = computed(() => ({\n  display: 'grid',\n  gridTemplateColumns: `repeat(${gridHeight.value}, ${cellSize.value}px)`,\n  gridTemplateRows: `repeat(${gridWidth.value}, ${cellSize.value}px)`,\n  // gap: '1px', no gap needed\n  \"--cell-size\": `${cellSize.value}px`,\n  width: 'fit-content',\n  minWidth: 'min-content'\n}));\n\nfunction handleGridWidthChange(e) {\n  const width = parseInt(e.target.value);\n  if (width >= 10 && width <= 40) {\n    settingsStore.setWordSearchGridSize(width, gridHeight.value, cellSize.value);\n    createGame();\n  }\n}\n\nfunction handleGridHeightChange(e) {\n  const height = parseInt(e.target.value);\n  if (height >= 8 && height <= 20) {\n    settingsStore.setWordSearchGridSize(gridWidth.value, height, cellSize.value);\n    createGame();\n  }\n}\n\nfunction handleCellSizeChange(e) {\n  console.log('handleCellSizeChange', e)\n  const size = parseInt(e.target.value);\n  if (size >= 16 && size <= 40) {\n    settingsStore.setWordSearchGridSize(gridWidth.value, gridHeight.value, size);\n  }\n}\n\nconst gameGrid = ref(null);\nconst grid = ref([]);\nconst gameWords = ref([]);\nconst foundWords = ref([]);\nconst score = ref(0);\nconst statusMessage = ref(\"\");\nconst selectedCells = ref([]);\nconst pointsEarned = ref(0);\n\nconst { POINTS_CONFIG, awardPoints, usePerk } = useGamePoints();\n\nconst allWordsFound = computed(() => {\n  return gameWords.value.length > 0 &&\n    gameWords.value.every(word => foundWords.value.includes(word.word.toUpperCase()));\n});\n\nfunction createGame() {\n  score.value = 0;\n  statusMessage.value = \"\";\n  selectedCells.value = [];\n  foundWords.value = [];\n  foundCells = reactive({});\n\n  // Initialize grid with correct dimensions\n  const rows = parseInt(gridHeight.value);\n  const cols = parseInt(gridWidth.value);\n\n  grid.value = Array(rows).fill().map(() => Array(cols).fill(\"\"));\n\n  let filteredWords = vocabularyStore.words.filter(\n    (wordObj) => wordObj.isActive\n  );\n  filteredWords = filteredWords.filter(\n    (wordObj) =>\n      wordObj.word.length <= gridWidth.value &&\n      wordObj.word.length <= gridHeight.value\n  );\n\n  if (filteredWords.length < 10) {\n    alert(\n      \"Não há palavras suficientes para iniciar o jogo. Por favor, ajuste os filtros ou adicione mais palavras que caibam na grade.\"\n    );\n    return;\n  }\n\n  const uniqueWords = Array.from(\n    new Set(filteredWords.map((wordObj) => wordObj.word.toUpperCase()))\n  );\n  if (uniqueWords.length < 10) {\n    alert(\n      \"Não há palavras únicas suficientes para iniciar o jogo. Por favor, ajuste os filtros ou adicione mais palavras.\"\n    );\n    return;\n  }\n\n  uniqueWords.sort(() => 0.5 - Math.random());\n  const selectedUnique = uniqueWords.slice(0, 10);\n  gameWords.value = selectedUnique.map((word) =>\n    filteredWords.find((wordObj) => wordObj.word.toUpperCase() === word)\n  );\n\n  let allWordsPlaced = gameWords.value.every((wordObj) => {\n    return placeWordInGrid(wordObj.word.toUpperCase());\n  });\n\n  if (!allWordsPlaced) {\n    createGame();\n    return;\n  }\n\n  fillEmptyCells();\n}\n\nfunction placeWordInGrid(word) {\n  const directions = [\"horizontal\", \"vertical\", \"diagonal-down\", \"diagonal-up\"];\n  const possibleDirections = directions.filter((direction) => {\n    const needsWidth = [\"horizontal\", \"diagonal-down\", \"diagonal-up\"].includes(direction);\n    const needsHeight = [\"vertical\", \"diagonal-down\"].includes(direction);\n    const needsInverseHeight = direction === \"diagonal-up\";\n\n    if (needsWidth && word.length > gridWidth.value) return false;\n    if (needsHeight && word.length > gridHeight.value) return false;\n    if (needsInverseHeight && word.length > gridHeight.value) return false;\n    return true;\n  });\n\n  if (possibleDirections.length === 0) {\n    console.error(`A palavra \"${word}\" é muito longa para caber na grade.`);\n    return false;\n  }\n\n  const positions = [];\n  for (const direction of possibleDirections) {\n    const maxRow = gridHeight.value - ([\"vertical\", \"diagonal-down\"].includes(direction) ? word.length : 0);\n    const minRow = direction === \"diagonal-up\" ? word.length - 1 : 0;\n    const maxCol = gridWidth.value - ([\"horizontal\", \"diagonal-down\", \"diagonal-up\"].includes(direction) ? word.length : 0);\n\n    for (let row = minRow; row < maxRow; row++) {\n      for (let col = 0; col < maxCol; col++) {\n        const posInfo = checkPosition(word, row, col, direction);\n        if (posInfo.canPlace) {\n          positions.push({\n            row,\n            col,\n            direction,\n            intersections: posInfo.intersections\n          });\n        }\n      }\n    }\n  }\n\n  positions.sort((a, b) => {\n    if (b.intersections === a.intersections) {\n      return Math.random() - 0.5;\n    }\n    return b.intersections - a.intersections;\n  });\n\n  if (positions.length > 0) {\n    const bestPos = positions[0];\n    placeWordAtPosition(word, bestPos.row, bestPos.col, bestPos.direction);\n    return true;\n  }\n\n  return false;\n}\n\nfunction checkPosition(word, startRow, startCol, direction) {\n  let canPlace = true;\n  let intersections = 0;\n\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    const currentCell = grid.value[row][col];\n    if (currentCell !== \"\") {\n      if (currentCell !== word[i]) {\n        canPlace = false;\n        break;\n      } else {\n        intersections++;\n      }\n    }\n  }\n\n  return { canPlace, intersections };\n}\n\nfunction placeWordAtPosition(word, startRow, startCol, direction) {\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    grid.value[row][col] = word[i];\n  }\n}\n\nfunction fillEmptyCells() {\n  const letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n  // Fix loop order to properly fill all cells\n  for (let row = 0; row < gridHeight.value; row++) {\n    for (let col = 0; col < gridWidth.value; col++) {\n      if (grid.value[row][col] === \"\") {\n        grid.value[row][col] = letters.charAt(\n          Math.floor(Math.random() * letters.length)\n        );\n      }\n    }\n  }\n}\n\nfunction handleCellClick(row, col) {\n  const cellKey = `${row}-${col}`;\n  if (selectedCells.value.some((cell) => cell.key === cellKey)) {\n    selectedCells.value = selectedCells.value.filter(\n      (cell) => cell.key !== cellKey\n    );\n  } else {\n    selectedCells.value.push({ row, col, key: cellKey });\n    if (selectedCells.value.length === 2) {\n      checkSelectedWord();\n    }\n  }\n}\n\nfunction isCellSelected(row, col) {\n  if (selectedCells.value.length === 2) {\n    const [first, second] = selectedCells.value;\n    if (first.row === second.row && row === first.row) {\n      const startCol = Math.min(first.col, second.col);\n      const endCol = Math.max(first.col, second.col);\n      return col >= startCol && col <= endCol;\n    }\n    if (first.col === second.col && col === first.col) {\n      const startRow = Math.min(first.row, second.row);\n      const endRow = Math.max(first.row, second.row);\n      return row >= startRow && row <= endRow;\n    }\n  }\n  return selectedCells.value.some(\n    (cell) => cell.row === row && cell.col === col\n  );\n}\n\nlet foundCells = reactive({});\n\nfunction isCellFound(row, col) {\n  return foundCells[`${row}-${col}`] === true;\n}\n\nfunction checkSelectedWord() {\n  if (selectedCells.value.length !== 2) return;\n\n  const [first, second] = selectedCells.value;\n  const rowDiff = second.row - first.row;\n  const colDiff = second.col - first.col;\n\n  const isDiagonal = Math.abs(rowDiff) === Math.abs(colDiff);\n  const isHorizontal = rowDiff === 0;\n  const isVertical = colDiff === 0;\n\n  if (!isHorizontal && !isVertical && !isDiagonal) {\n    statusMessage.value = \"Selecione letras em linha reta (horizontal, vertical ou diagonal).\";\n    resetSelection();\n    return;\n  }\n\n  let word = \"\";\n  let cellsToCheck = [];\n\n  if (isHorizontal) {\n    const [left, right] = first.col < second.col ? [first, second] : [second, first];\n    for (let c = left.col; c <= right.col; c++) {\n      word += grid.value[left.row][c];\n      cellsToCheck.push({ row: left.row, col: c });\n    }\n  } else if (isVertical) {\n    const [top, bottom] = first.row < second.row ? [first, second] : [second, first];\n    for (let r = top.row; r <= bottom.row; r++) {\n      word += grid.value[r][top.col];\n      cellsToCheck.push({ row: r, col: top.col });\n    }\n  } else {\n    const steps = Math.abs(rowDiff);\n    const rowStep = rowDiff / steps;\n    const colStep = colDiff / steps;\n\n    for (let i = 0; i <= steps; i++) {\n      const row = first.row + (i * rowStep);\n      const col = first.col + (i * colStep);\n      word += grid.value[row][col];\n      cellsToCheck.push({ row, col });\n    }\n  }\n\n  const upperWord = word.toUpperCase();\n  const reversedWord = upperWord.split(\"\").reverse().join(\"\");\n  const foundWordObj = gameWords.value.find(\n    (wordObj) =>\n      wordObj.word.toUpperCase() === upperWord ||\n      wordObj.word.toUpperCase() === reversedWord\n  );\n\n  if (\n    foundWordObj &&\n    !foundWords.value.includes(foundWordObj.word.toUpperCase())\n  ) {\n    foundWords.value.push(foundWordObj.word.toUpperCase());\n    score.value += 10;\n    cellsToCheck.forEach((c) => {\n      foundCells[`${c.row}-${c.col}`] = true;\n    });\n    statusMessage.value = `Você encontrou: ${foundWordObj.word.toUpperCase()}`;\n    resetSelection();\n    if (foundWords.value.length === gameWords.value.length) {\n      const points = calculateGamePoints();\n      awardPoints(points);\n      pointsEarned.value = points;\n      setTimeout(() => {\n        alert(\n          `Parabéns! Você encontrou todas as palavras com ${score.value} pontos.`\n        );\n        createGame();\n      }, 500);\n    }\n  } else {\n    score.value -= 1;\n    statusMessage.value = `Palavra não encontrada: ${upperWord}`;\n    setTimeout(() => {\n      resetSelection();\n    }, 1000);\n  }\n}\n\nfunction calculateGamePoints() {\n  const basePoints = gameWords.value.length * POINTS_CONFIG.WORD_FOUND;\n  const isPerfect = true;\n  return basePoints + POINTS_CONFIG.GAME_COMPLETION + (isPerfect ? POINTS_CONFIG.PERFECT_SCORE : 0);\n}\n\nasync function handlePerk(perkId) {\n  // Always deduct points before applying perk effect\n  const success = await usePerk(perkId);\n  if (!success) return;\n  if (perkId === 'hint') {\n    const unfoundWords = gameWords.value\n      .filter(word => !foundWords.value.includes(word.word.toUpperCase()));\n    if (unfoundWords.length > 0) {\n      const randomWord = unfoundWords[Math.floor(Math.random() * unfoundWords.length)];\n      const cells = findWordCells(randomWord.word.toUpperCase());\n      cells.forEach(cell => {\n        const el = document.querySelector(`[data-row=\"${cell.row}\"][data-col=\"${cell.col}\"]`);\n        if (el) {\n          el.classList.add('hint');\n          setTimeout(() => el.classList.remove('hint'), 1000);\n        }\n      });\n    }\n  }\n}\n\nfunction findWordCells(word) {\n  const cells = [];\n  const directions = [\"horizontal\", \"vertical\", \"diagonal-down\", \"diagonal-up\"];\n  for (let row = 0; row < gridHeight.value; row++) {\n    for (let col = 0; col < gridWidth.value; col++) {\n      directions.forEach(dir => {\n        const positions = getWordPositions(word, row, col, dir);\n        if (positions.length === word.length) {\n          cells.push(...positions);\n        }\n      });\n    }\n  }\n  return cells;\n}\n\nfunction getWordPositions(word, startRow, startCol, direction) {\n  const positions = [];\n  for (let i = 0; i < word.length; i++) {\n    let row = startRow;\n    let col = startCol;\n\n    switch (direction) {\n      case \"horizontal\":\n        col += i;\n        break;\n      case \"vertical\":\n        row += i;\n        break;\n      case \"diagonal-down\":\n        row += i;\n        col += i;\n        break;\n      case \"diagonal-up\":\n        row -= i;\n        col += i;\n        break;\n    }\n\n    const currentCell = grid.value[row]?.[col];\n    if (currentCell === undefined || currentCell !== word[i]) {\n      return [];\n    }\n    positions.push({ row, col });\n  }\n  return positions;\n}\n\nfunction resetSelection() {\n  selectedCells.value = [];\n}\n\nonMounted(() => {\n  console.log('onMounted',\n    cellSize,\n    gridWidth,\n    gridHeight\n  );\n  createGame();\n});\n\n</script>\n\n<style scoped>\n.word-search-game {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  padding: 0.5rem;\n  height: 100%;\n  max-width: 100%;\n  overflow: hidden;\n}\n\n.game-container {\n  display: flex;\n  flex-direction: row;\n  gap: 1rem;\n  width: 100%;\n  padding: 0.5rem;\n  border-radius: var(--radius-md);\n  background-color: var(--surface-color);\n  box-shadow: var(--shadow-sm);\n  overflow: auto;\n  /* flex-wrap: wrap; */\n}\n\n.word-search-game-panel {\n  display: flex;\n  flex-direction: column;\n  gap: 1rem;\n  width: 30%;\n}\n\n.grid-controls {\n  display: flex;\n  /* flex-direction: column; */\n  flex-wrap: wrap;\n  gap: 0.5rem;\n  padding: 0.5rem;\n  background-color: var(--background-color);\n  border-radius: var(--radius-md);\n}\n\n.control-group {\n  display: flex;\n  flex-direction: column;\n  gap: 0.25rem;\n  width: 100%;\n}\n\n.control-group input[type=\"range\"] {\n  width: 100%;\n  height: 6px;\n  -webkit-appearance: none;\n  appearance: none;\n  background: var(--border-color);\n  border-radius: 3px;\n  outline: none;\n  padding: 0;\n  margin: 0;\n}\n\n.control-group input[type=\"range\"]::-webkit-slider-thumb {\n  -webkit-appearance: none;\n  appearance: none;\n  width: 16px;\n  height: 16px;\n  background: var(--primary-color);\n  border-radius: 50%;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n}\n\n.control-group input[type=\"range\"]::-moz-range-thumb {\n  width: 16px;\n  height: 16px;\n  background: var(--primary-color);\n  border-radius: 50%;\n  cursor: pointer;\n  transition: background-color 0.2s ease;\n  border: none;\n}\n\n.control-group input[type=\"range\"]:hover::-webkit-slider-thumb {\n  background: var(--accent-color);\n}\n\n.control-group input[type=\"range\"]:hover::-moz-range-thumb {\n  background: var(--accent-color);\n}\n\n.control-group label {\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n  white-space: nowrap;\n}\n\n.game-grid-container {\n  display: flex;\n  /* justify-content: center; */\n  /* align-items: center; */\n  overflow: auto;\n  width: 100%;\n  /* padding: 0.5rem; */\n  /* max-width: 100vw; */\n  -webkit-overflow-scrolling: touch;\n  flex-wrap: wrap;\n}\n\n.game-grid {\n  display: grid;\n  /* gap: 1px; */\n  background-color: var(--border-color);\n  /* padding: 1px; */\n  /* border-radius: var(--radius-sm); */\n  width: fit-content;\n  margin: 20px auto;\n  border: 2px solid;\n}\n\n.cell {\n  width: var(--cell-size);\n  height: var(--cell-size);\n  background-color: var(--surface-color);\n  color: var(--text-color);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  cursor: pointer;\n  user-select: none;\n  position: relative;\n  transition: all 0.2s ease;\n  font-weight: 600;\n  font-size: calc(var(--cell-size) * 0.4);\n  touch-action: manipulation;\n}\n\n.cell:hover {\n  background-color: var(--hover-color);\n}\n\n.cell.selected {\n  background-color: var(--accent-color);\n  color: white;\n  transform: scale(1.05);\n  z-index: 1;\n}\n\n.cell.found {\n  background-color: var(--success-color);\n  color: white;\n  border-color: var(--success-color);\n}\n\n.cell.hint {\n  animation: hint-flash 1s ease;\n}\n\n@keyframes hint-flash {\n\n  0%,\n  100% {\n    background-color: var(--surface-color);\n  }\n\n  50% {\n    background-color: var(--accent-color);\n    color: white;\n  }\n}\n\n.status {\n  margin-top: 1rem;\n  font-size: 1rem;\n  color: var(--text-color);\n  padding: 0.5rem 1rem;\n  border-radius: var(--radius-sm);\n  background-color: var(--surface-color);\n}\n\n.word-list {\n  display: flex;\n  /* flex-wrap: wrap; */\n  gap: 0.5rem;\n  padding: 0.5rem;\n  margin: 0;\n  list-style: none;\n  width: 100%;\n  flex-direction: column;\n}\n\n.word-list li {\n  flex: 1 1 calc(50% - 0.5rem);\n  min-width: 150px;\n  font-size: 0.9rem;\n  color: var(--text-color);\n  text-align: left;\n  padding: 0.5rem;\n  border-radius: var(--radius-sm);\n  background-color: var(--background-color);\n  border: 1px solid var(--border-color);\n}\n\n.word-list li span {\n  display: block;\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n}\n\n.word-list li.found {\n  text-decoration: line-through;\n  color: var(--accent-color);\n  background-color: rgba(var(--success-color-rgb), 0.1);\n  border-color: var(--success-color);\n}\n\n.completion-message {\n  text-align: center;\n  margin-top: var(--spacing-lg);\n  padding: var(--spacing-md);\n  background: var(--surface-color);\n  border-radius: var(--radius-md);\n  border: 1px solid var(--border-color);\n}\n\n/* Dark mode support */\n:deep(.dark) .game-container {\n  background-color: var(--dark-surface-color);\n}\n\n:deep(.dark) .word-list {\n  background-color: var(--dark-surface-color);\n}\n\n:deep(.dark) .word-list li {\n  background-color: var(--dark-background-color);\n  border-color: var(--dark-border-color);\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .word-list li span {\n  color: var(--dark-text-secondary);\n}\n\n:deep(.dark) .word-list li.found {\n  color: var(--dark-accent-color);\n  background-color: rgba(72, 187, 120, 0.1);\n  border-color: var(--dark-accent-color);\n}\n\n:deep(.dark) .cell {\n  background-color: var(--dark-surface-color);\n  border-color: var(--dark-border-color);\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .cell:hover {\n  background-color: var(--dark-hover-color);\n}\n\n:deep(.dark) .cell.selected {\n  background-color: var(--dark-accent-color);\n  color: white;\n}\n\n:deep(.dark) .cell.found {\n  background-color: var(--dark-success-color, #2F855A);\n  border-color: var(--dark-success-color, #2F855A);\n}\n\n:deep(.dark) .status {\n  color: var(--dark-text-color);\n  background-color: var(--dark-surface-color);\n}\n\n@media (max-width: 768px) {\n  .word-search-game {\n    padding: 1rem;\n    overflow-y: auto;\n    overflow-x: hidden;\n  }\n\n  .game-container {\n    flex-direction: column;\n    padding: 1rem;\n    overflow-y: visible;\n    overflow-x: clip;\n  }\n\n  .word-search-game-panel {\n    width: 100%;\n  }\n\n  .game-grid-container {\n    overflow-y: visible;\n  }\n\n  .word-list {\n    flex-direction: column;\n  }\n\n  .cell {\n    font-size: calc(var(--cell-size) * 0.5);\n  }\n\n  .control-group label {\n    font-size: 0.8rem;\n  }\n\n  .word-list li {\n    flex: 1 1 100%;\n    min-width: 0;\n    font-size: 0.85rem;\n    padding: 0.4rem;\n  }\n\n  .status {\n    font-size: 0.85rem;\n    padding: 0.4rem 0.8rem;\n  }\n}\n</style>\n"],"names":["settingsStore","useSettingsStore","vocabularyStore","useVocabularyStore","cellSize","computed","settings","wordSearchGame","gridWidth","gridHeight","gridStyle","display","gridTemplateColumns","value","gridTemplateRows","width","minWidth","handleGridWidthChange","e","parseInt","target","setWordSearchGridSize","createGame","handleGridHeightChange","height","handleCellSizeChange","size","gameGrid","ref","grid","gameWords","foundWords","score","statusMessage","selectedCells","pointsEarned","POINTS_CONFIG","awardPoints","usePerk","useGamePoints","allWordsFound","length","every","word","includes","toUpperCase","foundCells","reactive","rows","cols","Array","fill","map","filteredWords","words","filter","wordObj","isActive","alert","uniqueWords","from","Set","sort","Math","random","selectedUnique","slice","find","possibleDirections","direction","needsWidth","needsHeight","needsInverseHeight","positions","maxRow","minRow","maxCol","row","col","posInfo","checkPosition","canPlace","push","intersections","a","b","bestPos","startRow","startCol","i","placeWordAtPosition","placeWordInGrid","letters","charAt","floor","fillEmptyCells","currentCell","handleCellClick","cellKey","some","cell","key","first","second","rowDiff","colDiff","isDiagonal","abs","isHorizontal","isVertical","resetSelection","cellsToCheck","left","right","c","top","bottom","r","steps","rowStep","colStep","upperWord","reversedWord","split","reverse","join","foundWordObj","forEach","points","WORD_FOUND","GAME_COMPLETION","PERFECT_SCORE","setTimeout","checkSelectedWord","isCellSelected","min","endCol","max","endRow","isCellFound","async","handlePerk","perkId","unfoundWords","cells","directions","dir","getWordPositions","findWordCells","el","document","querySelector","classList","add","remove","_a","onMounted"],"mappings":"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"}