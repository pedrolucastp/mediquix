{"version":3,"file":"CrosswordsGame-BKhiEL0l.js","sources":["../../src/views/CrosswordsGame.vue"],"sourcesContent":["<template>\n  <div class=\"crosswords-game\">\n    <GamePerksMenu :availablePerks=\"['hint', 'extra_time', 'skip']\" @perk-activated=\"handlePerk\" />\n    <div id=\"crossword-container\">\n      <div id=\"crossword\" :style=\"gridStyle\">\n        <template v-for=\"row in gridRows\" :key=\"row\">\n          <div v-for=\"col in gridCols\" :key=\"`${row}-${col}`\" class=\"cell\" :class=\"{ empty: !getCell(row, col) }\"\n            :style=\"getCell(row, col) ? getHighlightedCellBorder(row, col) : {}\">\n            <template v-if=\"getCell(row, col)\">\n              <span v-if=\"isStartingCell(row, col)\" class=\"clue-number\">\n                {{ getWordNumber(row, col) }}\n              </span>\n              <input :id=\"`cell-${row}-${col}`\" :ref=\"el => cellRefs[`${row}-${col}`] = el\" maxLength=\"1\"\n                :data-row=\"row\" :data-col=\"col\" :data-correct=\"getCell(row, col)\" :data-words=\"getCellWords(row, col)\"\n                :style=\"{ backgroundColor: getCellColor(row, col) }\" @input=\"handleInput\"\n                @click=\"handleCellClick(row, col)\" />\n            </template>\n          </div>\n        </template>\n      </div>\n\n      <div id=\"clues\">\n        <h1>Palavras Cruzadas</h1>\n        <SelectorsComponent @specialty-change=\"startGame(true)\" @difficulty-change=\"startGame(true)\" />\n        <div class=\"button-container\">\n          <button id=\"check-button\" @click=\"checkAnswers\">Verificar Respostas</button>\n          <button id=\"new-game-button\" @click=\"startGame(true)\">Novo Jogo</button>\n        </div>\n        <ul id=\"clue-list\" :style=\"{ display: isLoading ? 'none' : 'block' }\">\n          <li v-for=\"word in placedWords\" :key=\"word.number\" :class=\"{ 'highlighted': isClueHighlighted(word.number) }\"\n            @click=\"highlightWord(word)\" :style=\"{ borderBottom: `2px solid ${word.color}` }\" :title=\"word.word\">\n            {{ word.number }}. {{ word.clue }}\n            ({{ word.direction === 'across' ? 'Horizontal' : 'Vertical' }})\n          </li>\n        </ul>\n      </div>\n    </div>\n    <div v-if=\"isLoading\" class=\"loading-overlay\">\n      <div class=\"loading-message\">\n        <p>Gerando palavras cruzadas...</p>\n        <p>Tentativa {{ currentAttempt }} de {{ GAME_ATTEMPTS }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted, reactive } from 'vue'\nimport { useVocabularyStore } from '@/store/vocabulary'\nimport SelectorsComponent from '@/components/SelectorsComponent.vue'\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport GamePerksMenu from '@/components/game/GamePerksMenu.vue'\n\nconst { usePerk } = useGamePoints();\n\n// Constants\nconst PLACEMENT_DELAY = 20; // 500ms delay between attempts\nconst GAME_ATTEMPTS = 5;\nconst WORD_COUNT = 5\nconst GRID_ROWS = 25\nconst GRID_COLS = 30\nconst WORD_COLORS = [\n  '#FF6B6B', // coral red\n  '#4ECDC4', // turquoise\n  '#45B7D1', // sky blue\n  '#96CEB4', // sage green\n  '#ff24c0', // pink\n  '#D4A5A5', // dusty rose\n  '#9B97B2', // muted purple\n  '#FFB347', // pastel orange\n  '#87CEEB', // light blue\n  '#98FB98'  // pale green\n]\nconst GRID_CENTER_ROW = Math.floor(GRID_ROWS / 2)\nconst GRID_CENTER_COL = Math.floor(GRID_COLS / 2)\n\n// Refs\nconst grid = ref([])\nconst placedWords = ref([])\nconst currentWord = ref(null)\nconst currentDirection = ref('across')\nconst highlightedCells = ref(new Set())\nconst highlightedIntersections = ref(new Set())\nconst highlightedClue = ref(null)\nconst cellRefs = reactive({})\nconst isLoading = ref(false)\nconst currentAttempt = ref(1)\n\n// Stores\nconst vocabularyStore = useVocabularyStore()\n\n// Add a flag to track initial load\nconst isInitialLoad = ref(true)\n\n// Add to the refs section\nconst lastClickedCell = ref({ row: null, col: null, wordIndex: 0 })\n\n// Computed\nconst gridStyle = computed(() => ({\n  gridTemplateColumns: `repeat(${GRID_COLS}, 40px)`,\n  gridTemplateRows: `repeat(${GRID_ROWS}, 40px)`\n}))\n\nconst gridRows = computed(() => Array.from({ length: GRID_ROWS }, (_, i) => i))\nconst gridCols = computed(() => Array.from({ length: GRID_COLS }, (_, i) => i))\n\n// Methods\nfunction getCell(row, col) {\n  return grid.value[row]?.[col] || null\n}\n\nfunction getCellWords(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return JSON.stringify(cellWords.map(word => ({\n    wordNumber: word.number,\n    direction: word.direction\n  })))\n}\n\nfunction getCellColor(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return cellWords.length > 0 ? getCell(row, col) === ' ' ? 'white' : cellWords[0].color + ((isHighlighted(row, col) || isIntersectionHighlighted(row, col)) ? '' : '70') : 'transparent';\n}\n\n//Function to help to determine the border of a highlited cell when a word is selected, apply a 3px solid darkgrey;\n// when the word is in horizontal direction, \n// all cells of the current selected word should have border on top and bottom;\n// the first cell should also have border on left;\n// the last  cell should also have border on right; \n\n// when the word is in vertical direction,\n// all cells of the current selected word should have border on left and right;\n// the first cell should also have border on top;\n// the last cell should also have border on bottom;\n\nfunction getHighlightedCellBorder(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n\n  if (cellWords.length === 0) return {};\n\n  // Initialize default border style\n  const styles = {\n    border: '1px solid var(--dark-border-color)',\n    backgroundColor: 'transparent'\n  };\n\n  let hasHighlightedHorizontal = false;\n  let hasHighlightedVertical = false;\n\n  // First pass: check if we have any highlighted words\n  cellWords.forEach(word => {\n    const positions = word.positions.map(pos => `${pos.row}-${pos.col}`);\n    const isHighlightedWord = positions.some(pos => highlightedCells.value.has(pos));\n    \n    if (isHighlightedWord) {\n      styles.backgroundColor = 'rgba(255, 255, 0, 0.1)';\n      if (word.direction === 'across') {\n        hasHighlightedHorizontal = true;\n      } else {\n        hasHighlightedVertical = true;\n      }\n    }\n  });\n\n  // Second pass: apply borders based on direction\n  if (hasHighlightedHorizontal) {\n    styles.borderTop = '3px solid darkgrey';\n    styles.borderBottom = '3px solid darkgrey';\n  }\n  if (hasHighlightedVertical) {\n    styles.borderLeft = '3px solid darkgrey';\n    styles.borderRight = '3px solid darkgrey';\n  }\n\n  // Third pass: handle edges\n  cellWords.forEach(word => {\n    const positions = word.positions.map(pos => `${pos.row}-${pos.col}`);\n    const isHighlightedWord = positions.some(pos => highlightedCells.value.has(pos));\n    \n    if (isHighlightedWord) {\n      if (word.direction === 'across' && hasHighlightedHorizontal) {\n        if (positions[0] === `${row}-${col}`) {\n          styles.borderLeft = '3px solid darkgrey';\n        }\n        if (positions[positions.length - 1] === `${row}-${col}`) {\n          styles.borderRight = '3px solid darkgrey';\n        }\n      }\n      if (word.direction === 'down' && hasHighlightedVertical) {\n        if (positions[0] === `${row}-${col}`) {\n          styles.borderTop = '3px solid darkgrey';\n        }\n        if (positions[positions.length - 1] === `${row}-${col}`) {\n          styles.borderBottom = '3px solid darkgrey';\n        }\n      }\n    }\n  });\n\n  return styles;\n}\n\nfunction isStartingCell(row, col) {\n  return placedWords.value.some(word => {\n    if (word.row === row && word.col === col) {\n      return true;\n    }\n    return false;\n  })\n}\n\nfunction getWordNumber(row, col) {\n  const word = placedWords.value.find(w => w.row === row && w.col === col)\n  return word?.number\n}\n\nfunction isHighlighted(row, col) {\n  return highlightedCells.value.has(`${row}-${col}`)\n}\n\nfunction isIntersectionHighlighted(row, col) {\n  return highlightedIntersections.value.has(`${row}-${col}`)\n}\n\nfunction isClueHighlighted(number) {\n  return highlightedClue.value === number\n}\n\nfunction highlightWord(wordObj) {\n  clearHighlights()\n\n  wordObj.positions.forEach(pos => {\n    highlightedCells.value.add(`${pos.row}-${pos.col}`)\n  })\n\n  highlightedClue.value = wordObj.number\n}\n\nfunction handleCellClick(row, col) {\n  const cellWords = JSON.parse(getCellWords(row, col))\n  if (cellWords.length === 0) return\n\n  // Reset word index if clicking a different cell\n  if (lastClickedCell.value.row !== row || lastClickedCell.value.col !== col) {\n    lastClickedCell.value = { row, col, wordIndex: 0 }\n  } else {\n    // Cycle through words at the same cell\n    lastClickedCell.value.wordIndex = (lastClickedCell.value.wordIndex + 1) % cellWords.length\n  }\n\n  const selectedWord = placedWords.value.find(w => \n    w.number === cellWords[lastClickedCell.value.wordIndex].wordNumber\n  )\n\n  if (selectedWord) {\n    highlightWord(selectedWord)\n    const input = cellRefs[`${row}-${col}`]\n    if (input) {\n      input.select()\n    }\n  }\n}\n\nfunction clearHighlights() {\n  highlightedCells.value.clear()\n  highlightedIntersections.value.clear()\n  highlightedClue.value = null\n}\n\nfunction normalizeString(str) {\n  return str.normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toUpperCase()\n    .trim()\n}\n\nfunction handleInput(event) {\n  const input = event.target\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n\n  // Set direction and highlight word if needed\n  if (cellWords && cellWords.length > 0 && (!currentWord.value || !isInputPartOfCurrentWord(input))) {\n    currentWord.value = cellWords[0]\n    currentDirection.value = cellWords[0].direction\n    const word = placedWords.value.find(w => w.number === cellWords[0].wordNumber)\n    if (word) {\n      highlightWord(word)\n    }\n  }\n\n  // Handle backspace (when input becomes empty or no data event)\n  if (!event.data || input.value === '') {\n    input.value = '' // Ensure the current cell is empty\n    moveToPreviousInput(input)\n    return\n  }\n\n  // Handle normal typing (overwrite mode)\n\n  input.value = event.data.toUpperCase()\n  input.select()\n  moveToNextInput(input)\n}\n\nfunction moveToNextInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let nextRow = currentRow\n  let nextCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    nextCol++\n  } else {\n    nextRow++\n  }\n\n  const nextInput = cellRefs[`${nextRow}-${nextCol}`]\n  if (nextInput && isInputPartOfCurrentWord(nextInput)) {\n    nextInput.focus()\n  }\n}\n\nfunction moveToPreviousInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let prevRow = currentRow\n  let prevCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    prevCol--\n  } else {\n    prevRow--\n  }\n\n  const prevInput = cellRefs[`${prevRow}-${prevCol}`]\n  if (prevInput && isInputPartOfCurrentWord(prevInput)) {\n    prevInput.focus()\n    prevInput.select() // Select text in previous cell\n  }\n}\n\nfunction isInputPartOfCurrentWord(input) {\n  if (!currentWord.value || !currentDirection.value) return false;\n\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n  if (!cellWords || cellWords.length === 0) return false;\n\n  // Check if any word in this cell matches our current direction and is part of our path\n  const currentWordObj = placedWords.value.find(w => w.number === currentWord.value.wordNumber);\n  if (!currentWordObj) return false;\n\n  // Get the input's position\n  const row = parseInt(input.dataset.row);\n  const col = parseInt(input.dataset.col);\n\n  // Check if this position is part of our current word's path\n  if (currentDirection.value === 'across') {\n    return row === currentWordObj.row &&\n      col >= currentWordObj.col &&\n      col < currentWordObj.col + currentWordObj.word.length;\n  } else {\n    return col === currentWordObj.col &&\n      row >= currentWordObj.row &&\n      row < currentWordObj.row + currentWordObj.word.length;\n  }\n}\n\nfunction checkAnswers() {\n  let allCorrect = true\n\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    const userInput = normalizeString(input.value || '')\n    const correctInput = normalizeString(input.dataset.correct)\n    if (userInput === correctInput) {\n      input.style.backgroundColor = '#b2ffb2'\n    } else {\n      input.style.backgroundColor = '#ffb2b2'\n      input.value = input.dataset.correct // Show correct letter\n      input.style.color = '#FF0000' // Make incorrect answers red\n      allCorrect = false\n    }\n  }\n\n  if (allCorrect) {\n    alert('Parabéns! Você completou corretamente!')\n    startGame() // Start new game without level increment\n  } else {\n    console.log('Existem erros em suas respostas. As respostas corretas estão em vermelho.')\n  }\n}\n\nfunction initializeGrid() {\n  // Clear the grid array\n  grid.value = []\n  for (let i = 0; i < GRID_ROWS; i++) {\n    grid.value.push(new Array(GRID_COLS).fill(null))\n  }\n\n  // Clear all input values and styling\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    if (input) {\n      input.value = ''\n      input.style.backgroundColor = 'transparent'\n      input.style.color = 'var(--text-color)'\n    }\n  }\n\n  // Clear placed words and highlights\n  placedWords.value = []\n  clearHighlights()\n\n  // Reset any game state\n  currentWord.value = null\n  currentDirection.value = 'across'\n\n  grid.value.forEach(row => row.fill(null));\n}\n\n\nfunction canPlaceWord(word, row, col, direction) {\n  if (direction === 'across') {\n    if (col < 0 || col + word.length > GRID_COLS || row < 0 || row >= GRID_ROWS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row][col + i];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const above = row > 0 ? grid.value[row - 1][col + i] : null;\n      const below = row < GRID_ROWS - 1 ? grid.value[row + 1][col + i] : null;\n\n      if ((above && !isPartOfWord(row - 1, col + i)) ||\n        (below && !isPartOfWord(row + 1, col + i))) {\n        return false;\n      }\n    }\n\n    const before = col > 0 ? grid.value[row][col - 1] : null;\n    const after = col + word.length < GRID_COLS ? grid.value[row][col + word.length] : null;\n    if (before || after) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n\n  } else if (direction === 'down') {\n    if (row < 0 || row + word.length > GRID_ROWS || col < 0 || col >= GRID_COLS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row + i][col];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const left = col > 0 ? grid.value[row + i][col - 1] : null;\n      const right = col < GRID_COLS - 1 ? grid.value[row + i][col + 1] : null;\n\n      if ((left && !isPartOfWord(row + i, col - 1)) ||\n        (right && !isPartOfWord(row + i, col + 1))) {\n        return false;\n      }\n    }\n\n    const above = row > 0 ? grid.value[row - 1][col] : null;\n    const below = row + word.length < GRID_ROWS ? grid.value[row + word.length][col] : null;\n    if (above || below) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n  }\n  return false;\n}\n\nfunction isPartOfWord(row, col) {\n  return placedWords.value.some(wordObj => {\n    if (wordObj.direction === 'across') {\n      return row === wordObj.row && col >= wordObj.col && col < wordObj.col + wordObj.word.length\n    } else if (wordObj.direction === 'down') {\n      return col === wordObj.col && row >= wordObj.row && row < wordObj.row + wordObj.word.length\n    }\n    return false\n  })\n}\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function visualizePlacement(word, row, col, direction, temp = true) {\n  const positions = [];\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] === null) {\n        grid.value[row][col + i] = temp ? '?' : word[i];\n        positions.push({ row, col: col + i });\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] === null) {\n        grid.value[row + i][col] = temp ? '?' : word[i];\n        positions.push({ row: row + i, col });\n      }\n    }\n  }\n\n  if (temp) {\n    await sleep(PLACEMENT_DELAY);\n    positions.forEach(pos => {\n      if (grid.value[pos.row][pos.col] === '?') {\n        grid.value[pos.row][pos.col] = null;\n      }\n    });\n  }\n  return positions;\n}\n\nfunction countIntersections(word, row, col, direction) {\n  let intersections = 0;\n\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] !== null && grid.value[row][col + i] === word[i]) {\n        intersections++;\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] !== null && grid.value[row + i][col] === word[i]) {\n        intersections++;\n      }\n    }\n  }\n\n  return intersections;\n}\n\nfunction findAllPossiblePositions(word, direction) {\n  const positions = [];\n\n  for (let row = 0; row < GRID_ROWS; row++) {\n    for (let col = 0; col < GRID_COLS; col++) {\n      if (canPlaceWord(word, row, col, direction)) {\n        const intersections = countIntersections(word, row, col, direction);\n        positions.push({\n          row,\n          col,\n          direction,\n          intersections\n        });\n      }\n    }\n  }\n\n  // Sort by number of intersections in descending order\n  positions.sort((a, b) => b.intersections - a.intersections);\n\n  return positions;\n}\n\nasync function placeRemainingWords(availableWords) {\n\n  while (placedWords.value.length < WORD_COUNT) {\n    let placed = false;\n    const triedIndices = new Set();\n\n    // Keep trying random words until we place one or exhaust all options\n    while (!placed && triedIndices.size < availableWords.length) {\n      let randomIndex;\n      do {\n        randomIndex = Math.floor(Math.random() * availableWords.length);\n      } while (triedIndices.has(randomIndex));\n\n      triedIndices.add(randomIndex);\n      const word = availableWords[randomIndex];\n      const allPossiblePositions = [];\n\n      // Find all possible positions in both directions\n      for (const direction of ['across', 'down']) {\n        const positionsInDirection = await findAllPossiblePositions(word.word, direction);\n        allPossiblePositions.push(...positionsInDirection);\n      }\n\n      // If we found valid positions\n      if (allPossiblePositions.length > 0) {\n        // Sort by intersections\n        allPossiblePositions.sort((a, b) => b.intersections - a.intersections);\n\n        // Take top 3 positions when available\n        const topPositions = allPossiblePositions.slice(0, Math.min(3, allPossiblePositions.length));\n\n        // Randomly select from top positions\n        const selectedPosition = topPositions[Math.floor(Math.random() * topPositions.length)];\n\n        // Visualize the attempt\n        await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, true);\n\n        // Place the word\n        const positions = await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, false);\n\n        if (positions.length > 0) {\n          placedWords.value.push({\n            word: word.word,\n            clue: word.clue,\n            row: selectedPosition.row,\n            col: selectedPosition.col,\n            direction: selectedPosition.direction,\n            positions: positions,\n            number: placedWords.value.length + 1,\n\n            // Assign a color based on the amount of available colors.\n            // color: WORD_COLORS[placedWords.value.length]\n            color: WORD_COLORS[placedWords.value.length % WORD_COLORS.length]\n          });\n          availableWords.splice(randomIndex, 1);\n          placed = true;\n          break;\n        }\n      }\n    }\n\n    if (!placed) {\n      console.log('No more words can be placed with current configuration');\n      return false;\n    }\n  }\n\n  return placedWords.value.length === WORD_COUNT;\n}\n\nasync function generateCrossword(words) {\n  if (currentAttempt.value > GAME_ATTEMPTS) {\n    console.log('Maximum attempts reached');\n    return false;\n  }\n\n  console.log(`Attempt ${currentAttempt.value} of 10`);\n  initializeGrid();\n  setTimeout(() => scrollToGridCenter(), 100)\n\n\n  // Create a copy of words array to work with\n  const availableWords = [...words];\n  const triedIndices = new Set();\n\n  // Try to place first word\n  while (triedIndices.size < availableWords.length) {\n    let randomIndex;\n    do {\n      randomIndex = Math.floor(Math.random() * availableWords.length);\n\n    } while (triedIndices.has(randomIndex));\n\n    triedIndices.add(randomIndex);\n    const firstWord = availableWords[randomIndex];\n\n    // Try to place the first word horizontally in the center\n    const positions = await visualizePlacement(\n      firstWord.word,\n      GRID_CENTER_ROW,\n      Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n      'across',\n      false\n    );\n\n    if (positions.length > 0) {\n      placedWords.value.push({\n        word: firstWord.word,\n        clue: firstWord.clue,\n        row: GRID_CENTER_ROW,\n        col: Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n        direction: 'across',\n        positions: positions,\n        number: 1,\n        color: WORD_COLORS[0]\n      });\n\n      availableWords.splice(randomIndex, 1);\n\n      // Try to place remaining words with the new strategy\n      const success = await placeRemainingWords(availableWords);\n      if (success) {\n        return true;\n      }\n    }\n  }\n\n  currentAttempt.value++;\n  return false;\n}\n\nfunction scrollToGridCenter() {\n  const crosswordDiv = document.getElementById('crossword')\n  if (crosswordDiv) {\n    const scrollLeft = (crosswordDiv.scrollWidth - crosswordDiv.clientWidth) / 2\n    const scrollTop = (crosswordDiv.scrollHeight - crosswordDiv.clientHeight) / 2\n    crosswordDiv.scrollTo({\n      left: scrollLeft,\n      top: scrollTop,\n      behavior: 'smooth'\n    })\n  }\n}\n\nasync function startGame(force = false) {\n  if (!force && !isInitialLoad.value) {\n    return\n  }\n  \n  try {\n    isLoading.value = true\n    const words = vocabularyStore.filteredWords\n    const success = await generateCrossword(words)\n\n    if (!success && currentAttempt.value < GAME_ATTEMPTS) {\n      await startGame(true)\n    }\n  } catch (error) {\n    console.error('Error generating crossword:', error)\n  } finally {\n    isLoading.value = false\n    clearHighlights()\n    isInitialLoad.value = false\n  }\n}\n\n/**\n * @function handlePerk\n * @param {string} perkId - The perk to activate\n * @returns {Promise<void>}\n * @description Deducts points and applies the perk effect. 'hint' reveals a random letter in the grid.\n */\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n  if (perkId === 'hint') {\n    // Reveal a random letter in the crossword grid\n    const allInputs = Object.values(cellRefs).filter(input => input && input.value === '');\n    if (allInputs.length > 0) {\n      const randomInput = allInputs[Math.floor(Math.random() * allInputs.length)];\n      randomInput.value = randomInput.dataset.correct;\n      randomInput.style.backgroundColor = '#ffe066';\n      setTimeout(() => {\n        randomInput.style.backgroundColor = '';\n      }, 1000);\n    }\n  } else if (perkId === 'extra_time') {\n    // Placeholder: implement timer logic if/when timer is added\n    // e.g., timer.value += 30;\n  } else if (perkId === 'skip') {\n    // Placeholder: implement skip logic if/when skipping clues is supported\n  }\n}\n\n// Initialization\nonMounted(() => {\n  startGame()\n})\n</script>\n\n<style scoped>\n#crossword-container {\n  display: flex;\n  justify-content: center;\n  align-items: flex-start;\n  gap: var(--spacing-lg, 2rem);\n  padding: var(--spacing-md, 1rem);\n  max-width: 1400px;\n  margin: 0 auto;\n  width: 100%;\n  min-height: calc(100vh - 200px);\n  position: relative;\n}\n\n.crosswords-game {\n  touch-action: none;\n  /* Prevent zooming on the page */\n  -ms-content-zooming: none;\n  -ms-touch-action: none;\n}\n\n#clues {\n  position: absolute;\n  top: var(--spacing-md, 1rem);\n  left: var(--spacing-md, 1rem);\n  width: 350px;\n  flex-shrink: 0;\n  padding: var(--spacing-md, 1rem);\n  border-radius: var(--radius-md, 8px);\n  box-shadow: var(--shadow-sm);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  max-height: 80vh;\n}\n\n\n#crossword {\n  display: grid;\n  gap: 0;\n  margin: 0;\n  padding: 2rem 2rem 2rem 350px;\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-md);\n  overflow: auto;\n  max-height: 80vh;\n  border: 2px solid var(--dark-border-color);\n  touch-action: manipulation;\n  -webkit-overflow-scrolling: touch;\n  -webkit-user-select: none;\n  user-select: none;\n  transform: scale(1);\n  transform-origin: center;\n  touch-action: pan-x pan-y pinch-zoom;\n  width: 100%;\n  position: relative;\n}\n\n/* Scrollbar styling */\n::-webkit-scrollbar {\n  width: 3px;\n  height: 3px;\n}\n\n::-webkit-scrollbar-track {\n  background: transparent;\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb {\n  background: var(--primary-color);\n\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: var(--accent-color);\n}\n\n/* Firefox */\n#crossword {\n  /* scrollbar-width: thin; */\n  /* scrollbar-color: var(--primary-color) var(--surface-color); */\n}\n\n@media (max-width: 768px) {\n  #crossword-container {\n    flex-direction: column;\n    align-items: center;\n    padding: 20px 0;\n  }\n\n  #crossword {\n    width: 90%;\n    order: 2;\n    padding: 10px;\n  }\n\n  #clues {\n    width: 100%;\n    position: relative;\n    top: 0;\n    left: 0;\n    order: 1;\n    max-height: none;\n  }\n}\n\n.cell {\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* Remove the default border since we handle it in getHighlightedCellBorder */\n  /* border: 1px solid var(--dark-border-color); */\n}\n\n.empty {\n  border: none;\n  background-color: transparent;\n}\n\n.cell input {\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  font-size: 16px;\n  padding: 0;\n  margin: 0;\n  border: none;\n  outline: none;\n  background: transparent;\n  text-transform: uppercase;\n  box-sizing: border-box;\n  border-radius: 0;\n}\n\n.cell:hover {\n  background-color: var(--hover-color, rgba(0, 0, 0, 0.05));\n}\n\n.cell input:focus {\n  background-color: var(--focus-color, rgba(var(--primary-rgb, 46, 204, 113), 0.1));\n}\n\n.cell input.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n.cell input.highlighted-intersection {\n  background-color: var(--intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n.cell .clue-number {\n  position: relative;\n  top: -8px;\n  left: 2px;\n  font-size: var(--clue-number-size, 0.75rem);\n  font-weight: bold;\n  color: var(--text-color);\n  width: 0;\n}\n\n/* #clues h2 {\n  font-size: 24px;\n  margin-bottom: 10px;\n  color: var(--text-color);\n} */\n\n#clue-list {\n  list-style: none;\n  margin-top: 20px;\n  overflow-y: auto;\n  list-style-position: outside;\n}\n\n#clue-list li {\n  margin-bottom: 0px;\n  font-size: 1rem;\n  text-align: left;\n  /* color: #eee; */\n  word-wrap: break-word;\n  cursor: pointer;\n  padding: 4px;\n}\n\n#clue-list li.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n  font-size: 1.1rem;\n}\n\n.button-container {\n  display: flex;\n  gap: 1rem;\n  justify-content: center;\n  /* margin-top: 20px; */\n}\n\n#check-button,\n#new-game-button {\n  padding: 8px 20px;\n  font-size: 14px;\n  /* background-color: var(--primary-color); */\n  background: #eee;\n\n  /* color: #fff; */\n  /* border: none; */\n  border-radius: 5px;\n  cursor: pointer;\n}\n\n#check-button:hover,\n#new-game-button:hover {\n  background-color: var(--accent-color);\n}\n\n@media (max-width: 480px) {\n  .cell {\n    width: 100%;\n    height: 100%;\n  }\n\n  .cell input {\n    font-size: 14px;\n  }\n}\n\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(255, 255, 255, 0.4);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 100;\n}\n\n.loading-message {\n  text-align: center;\n  padding: 20px;\n  background-color: var(--surface-color, #fff);\n  border-radius: 8px;\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--border-color);\n}\n\n:deep(.dark) .loading-overlay {\n  background: rgba(0, 0, 0, 0.4);\n}\n\n:deep(.dark) .cell {\n  border-color: var(--dark-border-color);\n}\n\n:deep(.dark) .cell:hover {\n  background-color: var(--dark-hover-color, rgba(255, 255, 255, 0.1));\n}\n\n:deep(.dark) .cell input {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .cell input:focus {\n  background-color: var(--dark-focus-color, rgba(var(--dark-primary-rgb, 46, 204, 113), 0.2));\n}\n\n:deep(.dark) .cell input.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n:deep(.dark) .cell input.highlighted-intersection {\n  background-color: var(--dark-intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n:deep(.dark) .cell .clue-number {\n  color: var(--dark-text-color);\n}\n\n/* :deep(.dark) #clues h2 {\n  color: var(--dark-text-color);\n} */\n\n:deep(.dark) #clue-list li {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) #clue-list li.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n</style>"],"names":["GRID_ROWS","GRID_COLS","usePerk","useGamePoints","WORD_COLORS","GRID_CENTER_ROW","Math","floor","GRID_CENTER_COL","grid","ref","placedWords","currentWord","currentDirection","highlightedCells","Set","highlightedIntersections","highlightedClue","cellRefs","reactive","isLoading","currentAttempt","vocabularyStore","useVocabularyStore","isInitialLoad","lastClickedCell","row","col","wordIndex","gridStyle","computed","gridTemplateColumns","gridTemplateRows","gridRows","Array","from","length","_","i","gridCols","getCell","value","getCellWords","cellWords","filter","word","positions","some","pos","JSON","stringify","map","wordNumber","number","direction","getCellColor","color","has","isHighlighted","isIntersectionHighlighted","getHighlightedCellBorder","styles","border","backgroundColor","hasHighlightedHorizontal","hasHighlightedVertical","forEach","borderTop","borderBottom","borderLeft","borderRight","isStartingCell","getWordNumber","find","w","highlightWord","wordObj","clearHighlights","add","clear","normalizeString","str","normalize","replace","toUpperCase","trim","handleInput","event","input","target","parse","dataset","words","isInputPartOfCurrentWord","data","currentInput","currentRow","parseInt","currentCol","prevRow","prevCol","prevInput","focus","select","moveToPreviousInput","nextRow","nextCol","nextInput","moveToNextInput","currentWordObj","checkAnswers","allCorrect","key","correct","style","alert","startGame","canPlaceWord","hasIntersection","currentCell","above","below","isPartOfWord","before","after","left","right","async","visualizePlacement","temp","push","ms","Promise","resolve","setTimeout","sleep","countIntersections","intersections","findAllPossiblePositions","sort","a","b","placeRemainingWords","availableWords","placed","triedIndices","size","randomIndex","random","allPossiblePositions","positionsInDirection","topPositions","slice","min","selectedPosition","clue","splice","generateCrossword","fill","initializeGrid","crosswordDiv","document","getElementById","scrollLeft","scrollWidth","clientWidth","scrollTop","scrollHeight","clientHeight","scrollTo","top","behavior","scrollToGridCenter","firstWord","force","filteredWords","error","handlePerk","perkId","allInputs","Object","values","randomInput","onMounted","selectedWord"],"mappings":"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"}