{"version":3,"file":"CrosswordsGame-CBrns0oO.js","sources":["../../src/views/CrosswordsGame.vue"],"sourcesContent":["<template>\n  <div class=\"crosswords-game\">\n    <div id=\"crossword-container\">\n\n      <div id=\"crossword\" :style=\"gridStyle\">\n        <template v-for=\"row in gridRows\" :key=\"row\">\n          <div v-for=\"col in gridCols\" :key=\"`${row}-${col}`\" class=\"cell\" :class=\"{ empty: !getCell(row, col) }\"\n            :style=\"getCell(row, col) ? getHighlightedCellBorder(row, col) : {}\">\n            <template v-if=\"getCell(row, col)\">\n              <span v-if=\"isStartingCell(row, col)\" class=\"clue-number\">\n                {{ getWordNumber(row, col) }}\n              </span>\n              <input :id=\"`cell-${row}-${col}`\" :ref=\"el => cellRefs[`${row}-${col}`] = el\" maxLength=\"1\"\n                :data-row=\"row\" :data-col=\"col\" :data-correct=\"getCell(row, col)\" :data-words=\"getCellWords(row, col)\"\n                :style=\"{ backgroundColor: getCellColor(row, col) }\" @input=\"handleInput\"\n                @click=\"handleCellClick(row, col)\" />\n            </template>\n          </div>\n        </template>\n      </div>\n\n      <div id=\"clues\">\n        <h1>Palavras Cruzadas</h1>\n        <GamePerksMenu :availablePerks=\"['hint', 'extra_time', 'skip']\" @perk-activated=\"handlePerk\" />\n        <SelectorsComponent @specialty-change=\"startGame(true)\" @difficulty-change=\"startGame(true)\" />\n\n        <ul id=\"clue-list\" :style=\"{ display: isLoading ? 'none' : 'block' }\">\n          <li v-for=\"word in placedWords\" :key=\"word.number\" :class=\"{ 'highlighted': isClueHighlighted(word.number) }\"\n            @click=\"highlightWord(word)\" :style=\"{ borderBottom: `2px solid ${word.color}` }\" :title=\"word.word\">\n            {{ word.number }}. {{ word.clue }}\n            ({{ word.direction === 'across' ? 'Horizontal' : 'Vertical' }})\n          </li>\n        </ul>\n      </div>\n\n      <div class=\"button-container\">\n        <button id=\"check-button\" @click=\"checkAnswers\">Verificar Respostas</button>\n        <button id=\"new-game-button\" @click=\"startGame(true)\">Novo Jogo</button>\n      </div>\n    </div>\n    \n    <div v-if=\"isLoading\" class=\"loading-overlay\">\n      <div class=\"loading-message\">\n        <p>Gerando palavras cruzadas...</p>\n        <p>Tentativa {{ currentAttempt }} de {{ GAME_ATTEMPTS }}</p>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted, reactive } from 'vue'\nimport { useVocabularyStore } from '@/store/vocabulary'\nimport SelectorsComponent from '@/components/SelectorsComponent.vue'\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport GamePerksMenu from '@/components/game/GamePerksMenu.vue'\n\nconst { usePerk } = useGamePoints();\n\n// Constants\nconst PLACEMENT_DELAY = 20; // 500ms delay between attempts\nconst GAME_ATTEMPTS = 5;\nconst WORD_COUNT = 5\nconst GRID_ROWS = 25\nconst GRID_COLS = 30\nconst WORD_COLORS = [\n  '#FF6B6B', // coral red\n  '#4ECDC4', // turquoise\n  '#45B7D1', // sky blue\n  '#96CEB4', // sage green\n  '#ff24c0', // pink\n  '#D4A5A5', // dusty rose\n  '#9B97B2', // muted purple\n  '#FFB347', // pastel orange\n  '#87CEEB', // light blue\n  '#98FB98'  // pale green\n]\nconst GRID_CENTER_ROW = Math.floor(GRID_ROWS / 2)\nconst GRID_CENTER_COL = Math.floor(GRID_COLS / 2)\n\n// Refs\nconst grid = ref([])\nconst placedWords = ref([])\nconst currentWord = ref(null)\nconst currentDirection = ref('across')\nconst highlightedCells = ref(new Set())\nconst highlightedIntersections = ref(new Set())\nconst highlightedClue = ref(null)\nconst cellRefs = reactive({})\nconst isLoading = ref(false)\nconst currentAttempt = ref(1)\n\n// Stores\nconst vocabularyStore = useVocabularyStore()\n\n// Add a flag to track initial load\nconst isInitialLoad = ref(true)\n\n// Add to the refs section\nconst lastClickedCell = ref({ row: null, col: null, wordIndex: 0 })\n\n// Computed\nconst gridStyle = computed(() => ({\n  gridTemplateColumns: `repeat(${GRID_COLS}, 40px)`,\n  gridTemplateRows: `repeat(${GRID_ROWS}, 40px)`\n}))\n\nconst gridRows = computed(() => Array.from({ length: GRID_ROWS }, (_, i) => i))\nconst gridCols = computed(() => Array.from({ length: GRID_COLS }, (_, i) => i))\n\n// Methods\nfunction getCell(row, col) {\n  return grid.value[row]?.[col] || null\n}\n\nfunction getCellWords(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return JSON.stringify(cellWords.map(word => ({\n    wordNumber: word.number,\n    direction: word.direction\n  })))\n}\n\nfunction getCellColor(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n  return cellWords.length > 0 ? getCell(row, col) === ' ' ? 'white' : cellWords[0].color + ((isHighlighted(row, col) || isIntersectionHighlighted(row, col)) ? '' : '70') : 'transparent';\n}\n\n//Function to help to determine the border of a highlited cell when a word is selected, apply a 3px solid darkgrey;\n// when the word is in horizontal direction, \n// all cells of the current selected word should have border on top and bottom;\n// the first cell should also have border on left;\n// the last  cell should also have border on right; \n\n// when the word is in vertical direction,\n// all cells of the current selected word should have border on left and right;\n// the first cell should also have border on top;\n// the last cell should also have border on bottom;\n\nfunction getHighlightedCellBorder(row, col) {\n  const cellWords = placedWords.value.filter(word => {\n    return word.positions.some(pos => pos.row === row && pos.col === col)\n  })\n\n  if (cellWords.length === 0) return {};\n\n  // Initialize default border style\n  const styles = {\n    border: '1px solid var(--dark-border-color)',\n    backgroundColor: 'transparent'\n  };\n\n  let hasHighlightedHorizontal = false;\n  let hasHighlightedVertical = false;\n\n  // First pass: check if we have any highlighted words\n  cellWords.forEach(word => {\n    const positions = word.positions.map(pos => `${pos.row}-${pos.col}`);\n    const isHighlightedWord = positions.some(pos => highlightedCells.value.has(pos));\n\n    if (isHighlightedWord) {\n      styles.backgroundColor = 'rgba(255, 255, 0, 0.1)';\n      if (word.direction === 'across') {\n        hasHighlightedHorizontal = true;\n      } else {\n        hasHighlightedVertical = true;\n      }\n    }\n  });\n\n  // Second pass: apply borders based on direction\n  if (hasHighlightedHorizontal) {\n    styles.borderTop = '3px solid darkgrey';\n    styles.borderBottom = '3px solid darkgrey';\n  }\n  if (hasHighlightedVertical) {\n    styles.borderLeft = '3px solid darkgrey';\n    styles.borderRight = '3px solid darkgrey';\n  }\n\n  // Third pass: handle edges\n  cellWords.forEach(word => {\n    const positions = word.positions.map(pos => `${pos.row}-${pos.col}`);\n    const isHighlightedWord = positions.some(pos => highlightedCells.value.has(pos));\n\n    if (isHighlightedWord) {\n      if (word.direction === 'across' && hasHighlightedHorizontal) {\n        if (positions[0] === `${row}-${col}`) {\n          styles.borderLeft = '3px solid darkgrey';\n        }\n        if (positions[positions.length - 1] === `${row}-${col}`) {\n          styles.borderRight = '3px solid darkgrey';\n        }\n      }\n      if (word.direction === 'down' && hasHighlightedVertical) {\n        if (positions[0] === `${row}-${col}`) {\n          styles.borderTop = '3px solid darkgrey';\n        }\n        if (positions[positions.length - 1] === `${row}-${col}`) {\n          styles.borderBottom = '3px solid darkgrey';\n        }\n      }\n    }\n  });\n\n  return styles;\n}\n\nfunction isStartingCell(row, col) {\n  return placedWords.value.some(word => {\n    if (word.row === row && word.col === col) {\n      return true;\n    }\n    return false;\n  })\n}\n\nfunction getWordNumber(row, col) {\n  const word = placedWords.value.find(w => w.row === row && w.col === col)\n  return word?.number\n}\n\nfunction isHighlighted(row, col) {\n  return highlightedCells.value.has(`${row}-${col}`)\n}\n\nfunction isIntersectionHighlighted(row, col) {\n  return highlightedIntersections.value.has(`${row}-${col}`)\n}\n\nfunction isClueHighlighted(number) {\n  return highlightedClue.value === number\n}\n\nfunction highlightWord(wordObj) {\n  clearHighlights()\n\n  wordObj.positions.forEach(pos => {\n    highlightedCells.value.add(`${pos.row}-${pos.col}`)\n  })\n\n  highlightedClue.value = wordObj.number\n}\n\nfunction handleCellClick(row, col) {\n  const cellWords = JSON.parse(getCellWords(row, col))\n  if (cellWords.length === 0) return\n\n  // Reset word index if clicking a different cell\n  if (lastClickedCell.value.row !== row || lastClickedCell.value.col !== col) {\n    lastClickedCell.value = { row, col, wordIndex: 0 }\n  } else {\n    // Cycle through words at the same cell\n    lastClickedCell.value.wordIndex = (lastClickedCell.value.wordIndex + 1) % cellWords.length\n  }\n\n  const selectedWord = placedWords.value.find(w =>\n    w.number === cellWords[lastClickedCell.value.wordIndex].wordNumber\n  )\n\n  if (selectedWord) {\n    highlightWord(selectedWord)\n    const input = cellRefs[`${row}-${col}`]\n    if (input) {\n      input.select()\n    }\n  }\n}\n\nfunction clearHighlights() {\n  highlightedCells.value.clear()\n  highlightedIntersections.value.clear()\n  highlightedClue.value = null\n}\n\nfunction normalizeString(str) {\n  return str.normalize('NFD')\n    .replace(/[\\u0300-\\u036f]/g, '')\n    .toUpperCase()\n    .trim()\n}\n\nfunction handleInput(event) {\n  const input = event.target\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n\n  // Set direction and highlight word if needed\n  if (cellWords && cellWords.length > 0 && (!currentWord.value || !isInputPartOfCurrentWord(input))) {\n    currentWord.value = cellWords[0]\n    currentDirection.value = cellWords[0].direction\n    const word = placedWords.value.find(w => w.number === cellWords[0].wordNumber)\n    if (word) {\n      highlightWord(word)\n    }\n  }\n\n  // Handle backspace (when input becomes empty or no data event)\n  if (!event.data || input.value === '') {\n    input.value = '' // Ensure the current cell is empty\n    moveToPreviousInput(input)\n    return\n  }\n\n  // Handle normal typing (overwrite mode)\n\n  input.value = event.data.toUpperCase()\n  input.select()\n  moveToNextInput(input)\n}\n\nfunction moveToNextInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let nextRow = currentRow\n  let nextCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    nextCol++\n  } else {\n    nextRow++\n  }\n\n  const nextInput = cellRefs[`${nextRow}-${nextCol}`]\n  if (nextInput && isInputPartOfCurrentWord(nextInput)) {\n    nextInput.focus()\n  }\n}\n\nfunction moveToPreviousInput(currentInput) {\n  const currentRow = parseInt(currentInput.dataset.row)\n  const currentCol = parseInt(currentInput.dataset.col)\n\n  if (!currentWord.value || !currentDirection.value) return\n\n  let prevRow = currentRow\n  let prevCol = currentCol\n\n  if (currentDirection.value === 'across') {\n    prevCol--\n  } else {\n    prevRow--\n  }\n\n  const prevInput = cellRefs[`${prevRow}-${prevCol}`]\n  if (prevInput && isInputPartOfCurrentWord(prevInput)) {\n    prevInput.focus()\n    prevInput.select() // Select text in previous cell\n  }\n}\n\nfunction isInputPartOfCurrentWord(input) {\n  if (!currentWord.value || !currentDirection.value) return false;\n\n  const cellWords = JSON.parse(input.dataset.words || '[]')\n  if (!cellWords || cellWords.length === 0) return false;\n\n  // Check if any word in this cell matches our current direction and is part of our path\n  const currentWordObj = placedWords.value.find(w => w.number === currentWord.value.wordNumber);\n  if (!currentWordObj) return false;\n\n  // Get the input's position\n  const row = parseInt(input.dataset.row);\n  const col = parseInt(input.dataset.col);\n\n  // Check if this position is part of our current word's path\n  if (currentDirection.value === 'across') {\n    return row === currentWordObj.row &&\n      col >= currentWordObj.col &&\n      col < currentWordObj.col + currentWordObj.word.length;\n  } else {\n    return col === currentWordObj.col &&\n      row >= currentWordObj.row &&\n      row < currentWordObj.row + currentWordObj.word.length;\n  }\n}\n\nfunction checkAnswers() {\n  let allCorrect = true\n\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    const userInput = normalizeString(input.value || '')\n    const correctInput = normalizeString(input.dataset.correct)\n    if (userInput === correctInput) {\n      input.style.backgroundColor = '#b2ffb2'\n    } else {\n      input.style.backgroundColor = '#ffb2b2'\n      input.value = input.dataset.correct // Show correct letter\n      input.style.color = '#FF0000' // Make incorrect answers red\n      allCorrect = false\n    }\n  }\n\n  if (allCorrect) {\n    alert('Parabéns! Você completou corretamente!')\n    startGame() // Start new game without level increment\n  } else {\n    console.log('Existem erros em suas respostas. As respostas corretas estão em vermelho.')\n  }\n}\n\nfunction initializeGrid() {\n  // Clear the grid array\n  grid.value = []\n  for (let i = 0; i < GRID_ROWS; i++) {\n    grid.value.push(new Array(GRID_COLS).fill(null))\n  }\n\n  // Clear all input values and styling\n  for (const key in cellRefs) {\n    const input = cellRefs[key]\n    if (input) {\n      input.value = ''\n      input.style.backgroundColor = 'transparent'\n      input.style.color = 'var(--text-color)'\n    }\n  }\n\n  // Clear placed words and highlights\n  placedWords.value = []\n  clearHighlights()\n\n  // Reset any game state\n  currentWord.value = null\n  currentDirection.value = 'across'\n\n  grid.value.forEach(row => row.fill(null));\n}\n\n\nfunction canPlaceWord(word, row, col, direction) {\n  if (direction === 'across') {\n    if (col < 0 || col + word.length > GRID_COLS || row < 0 || row >= GRID_ROWS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row][col + i];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const above = row > 0 ? grid.value[row - 1][col + i] : null;\n      const below = row < GRID_ROWS - 1 ? grid.value[row + 1][col + i] : null;\n\n      if ((above && !isPartOfWord(row - 1, col + i)) ||\n        (below && !isPartOfWord(row + 1, col + i))) {\n        return false;\n      }\n    }\n\n    const before = col > 0 ? grid.value[row][col - 1] : null;\n    const after = col + word.length < GRID_COLS ? grid.value[row][col + word.length] : null;\n    if (before || after) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n\n  } else if (direction === 'down') {\n    if (row < 0 || row + word.length > GRID_ROWS || col < 0 || col >= GRID_COLS) return false;\n\n    let hasIntersection = false;\n    for (let i = 0; i < word.length; i++) {\n      const currentCell = grid.value[row + i][col];\n      if (currentCell) {\n        if (currentCell !== word[i]) return false;\n        hasIntersection = true;\n      }\n\n      const left = col > 0 ? grid.value[row + i][col - 1] : null;\n      const right = col < GRID_COLS - 1 ? grid.value[row + i][col + 1] : null;\n\n      if ((left && !isPartOfWord(row + i, col - 1)) ||\n        (right && !isPartOfWord(row + i, col + 1))) {\n        return false;\n      }\n    }\n\n    const above = row > 0 ? grid.value[row - 1][col] : null;\n    const below = row + word.length < GRID_ROWS ? grid.value[row + word.length][col] : null;\n    if (above || below) return false;\n\n    return placedWords.value.length === 0 || hasIntersection;\n  }\n  return false;\n}\n\nfunction isPartOfWord(row, col) {\n  return placedWords.value.some(wordObj => {\n    if (wordObj.direction === 'across') {\n      return row === wordObj.row && col >= wordObj.col && col < wordObj.col + wordObj.word.length\n    } else if (wordObj.direction === 'down') {\n      return col === wordObj.col && row >= wordObj.row && row < wordObj.row + wordObj.word.length\n    }\n    return false\n  })\n}\n\nasync function sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\nasync function visualizePlacement(word, row, col, direction, temp = true) {\n  const positions = [];\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] === null) {\n        grid.value[row][col + i] = temp ? '?' : word[i];\n        positions.push({ row, col: col + i });\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] === null) {\n        grid.value[row + i][col] = temp ? '?' : word[i];\n        positions.push({ row: row + i, col });\n      }\n    }\n  }\n\n  if (temp) {\n    await sleep(PLACEMENT_DELAY);\n    positions.forEach(pos => {\n      if (grid.value[pos.row][pos.col] === '?') {\n        grid.value[pos.row][pos.col] = null;\n      }\n    });\n  }\n  return positions;\n}\n\nfunction countIntersections(word, row, col, direction) {\n  let intersections = 0;\n\n  if (direction === 'across') {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row][col + i] !== null && grid.value[row][col + i] === word[i]) {\n        intersections++;\n      }\n    }\n  } else {\n    for (let i = 0; i < word.length; i++) {\n      if (grid.value[row + i][col] !== null && grid.value[row + i][col] === word[i]) {\n        intersections++;\n      }\n    }\n  }\n\n  return intersections;\n}\n\nfunction findAllPossiblePositions(word, direction) {\n  const positions = [];\n\n  for (let row = 0; row < GRID_ROWS; row++) {\n    for (let col = 0; col < GRID_COLS; col++) {\n      if (canPlaceWord(word, row, col, direction)) {\n        const intersections = countIntersections(word, row, col, direction);\n        positions.push({\n          row,\n          col,\n          direction,\n          intersections\n        });\n      }\n    }\n  }\n\n  // Sort by number of intersections in descending order\n  positions.sort((a, b) => b.intersections - a.intersections);\n\n  return positions;\n}\n\nasync function placeRemainingWords(availableWords) {\n\n  while (placedWords.value.length < WORD_COUNT) {\n    let placed = false;\n    const triedIndices = new Set();\n\n    // Keep trying random words until we place one or exhaust all options\n    while (!placed && triedIndices.size < availableWords.length) {\n      let randomIndex;\n      do {\n        randomIndex = Math.floor(Math.random() * availableWords.length);\n      } while (triedIndices.has(randomIndex));\n\n      triedIndices.add(randomIndex);\n      const word = availableWords[randomIndex];\n      const allPossiblePositions = [];\n\n      // Find all possible positions in both directions\n      for (const direction of ['across', 'down']) {\n        const positionsInDirection = await findAllPossiblePositions(word.word, direction);\n        allPossiblePositions.push(...positionsInDirection);\n      }\n\n      // If we found valid positions\n      if (allPossiblePositions.length > 0) {\n        // Sort by intersections\n        allPossiblePositions.sort((a, b) => b.intersections - a.intersections);\n\n        // Take top 3 positions when available\n        const topPositions = allPossiblePositions.slice(0, Math.min(3, allPossiblePositions.length));\n\n        // Randomly select from top positions\n        const selectedPosition = topPositions[Math.floor(Math.random() * topPositions.length)];\n\n        // Visualize the attempt\n        await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, true);\n\n        // Place the word\n        const positions = await visualizePlacement(word.word, selectedPosition.row, selectedPosition.col, selectedPosition.direction, false);\n\n        if (positions.length > 0) {\n          placedWords.value.push({\n            word: word.word,\n            clue: word.clue,\n            row: selectedPosition.row,\n            col: selectedPosition.col,\n            direction: selectedPosition.direction,\n            positions: positions,\n            number: placedWords.value.length + 1,\n\n            // Assign a color based on the amount of available colors.\n            // color: WORD_COLORS[placedWords.value.length]\n            color: WORD_COLORS[placedWords.value.length % WORD_COLORS.length]\n          });\n          availableWords.splice(randomIndex, 1);\n          placed = true;\n          break;\n        }\n      }\n    }\n\n    if (!placed) {\n      console.log('No more words can be placed with current configuration');\n      return false;\n    }\n  }\n\n  return placedWords.value.length === WORD_COUNT;\n}\n\nasync function generateCrossword(words) {\n  if (currentAttempt.value > GAME_ATTEMPTS) {\n    console.log('Maximum attempts reached');\n    return false;\n  }\n\n  console.log(`Attempt ${currentAttempt.value} of 10`);\n  initializeGrid();\n  setTimeout(() => scrollToGridCenter(), 100)\n\n\n  // Create a copy of words array to work with\n  const availableWords = [...words];\n  const triedIndices = new Set();\n\n  // Try to place first word\n  while (triedIndices.size < availableWords.length) {\n    let randomIndex;\n    do {\n      randomIndex = Math.floor(Math.random() * availableWords.length);\n\n    } while (triedIndices.has(randomIndex));\n\n    triedIndices.add(randomIndex);\n    const firstWord = availableWords[randomIndex];\n\n    // Try to place the first word horizontally in the center\n    const positions = await visualizePlacement(\n      firstWord.word,\n      GRID_CENTER_ROW,\n      Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n      'across',\n      false\n    );\n\n    if (positions.length > 0) {\n      placedWords.value.push({\n        word: firstWord.word,\n        clue: firstWord.clue,\n        row: GRID_CENTER_ROW,\n        col: Math.floor(GRID_CENTER_COL - firstWord.word.length / 2),\n        direction: 'across',\n        positions: positions,\n        number: 1,\n        color: WORD_COLORS[0]\n      });\n\n      availableWords.splice(randomIndex, 1);\n\n      // Try to place remaining words with the new strategy\n      const success = await placeRemainingWords(availableWords);\n      if (success) {\n        return true;\n      }\n    }\n  }\n\n  currentAttempt.value++;\n  return false;\n}\n\nfunction scrollToGridCenter() {\n  const crosswordDiv = document.getElementById('crossword')\n  if (crosswordDiv) {\n    const scrollLeft = (crosswordDiv.scrollWidth - crosswordDiv.clientWidth) / 2\n    const scrollTop = (crosswordDiv.scrollHeight - crosswordDiv.clientHeight) / 2\n    crosswordDiv.scrollTo({\n      left: scrollLeft,\n      top: scrollTop,\n      behavior: 'smooth'\n    })\n  }\n}\n\nasync function startGame(force = false) {\n  if (!force && !isInitialLoad.value) {\n    return\n  }\n\n  try {\n    isLoading.value = true\n    const words = vocabularyStore.filteredWords\n    const success = await generateCrossword(words)\n\n    if (!success && currentAttempt.value < GAME_ATTEMPTS) {\n      await startGame(true)\n    }\n  } catch (error) {\n    console.error('Error generating crossword:', error)\n  } finally {\n    isLoading.value = false\n    clearHighlights()\n    isInitialLoad.value = false\n  }\n}\n\n/**\n * @function handlePerk\n * @param {string} perkId - The perk to activate\n * @returns {Promise<void>}\n * @description Deducts points and applies the perk effect. 'hint' reveals a random letter in the grid.\n */\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n  if (perkId === 'hint') {\n    // Reveal a random letter in the crossword grid\n    const allInputs = Object.values(cellRefs).filter(input => input && input.value === '');\n    if (allInputs.length > 0) {\n      const randomInput = allInputs[Math.floor(Math.random() * allInputs.length)];\n      randomInput.value = randomInput.dataset.correct;\n      randomInput.style.backgroundColor = '#ffe066';\n      setTimeout(() => {\n        randomInput.style.backgroundColor = '';\n      }, 1000);\n    }\n  } else if (perkId === 'extra_time') {\n    // Placeholder: implement timer logic if/when timer is added\n    // e.g., timer.value += 30;\n  } else if (perkId === 'skip') {\n    // Placeholder: implement skip logic if/when skipping clues is supported\n  }\n}\n\n// Initialization\nonMounted(() => {\n  startGame()\n})\n</script>\n\n<style scoped>\n#crossword-container {\n  display: flex;\n  justify-content: center;\n  align-items: flex-start;\n  gap: var(--spacing-lg, 2rem);\n  padding: var(--spacing-md, 1rem);\n  max-width: 1400px;\n  margin: 0 auto;\n  width: 100%;\n  min-height: calc(100vh - 200px);\n  position: relative;\n}\n\n.crosswords-game {\n  touch-action: none;\n  /* Prevent zooming on the page */\n  -ms-content-zooming: none;\n  -ms-touch-action: none;\n}\n\n#clues {\n  position: absolute;\n  top: var(--spacing-md, 1rem);\n  left: var(--spacing-md, 1rem);\n  width: 350px;\n  flex-shrink: 0;\n  padding: var(--spacing-md, 1rem);\n  border-radius: var(--radius-md, 8px);\n  box-shadow: var(--shadow-sm);\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  max-height: 80vh;\n}\n\n\n#crossword {\n  display: grid;\n  gap: 0;\n  margin: 0;\n  padding: 2rem 2rem 2rem 350px;\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-md);\n  overflow: auto;\n  max-height: 80vh;\n  border: 2px solid var(--dark-border-color);\n  touch-action: manipulation;\n  -webkit-overflow-scrolling: touch;\n  -webkit-user-select: none;\n  user-select: none;\n  transform: scale(1);\n  transform-origin: center;\n  touch-action: pan-x pan-y pinch-zoom;\n  width: 100%;\n  position: relative;\n}\n\n/* Scrollbar styling */\n::-webkit-scrollbar {\n  width: 3px;\n  height: 3px;\n}\n\n::-webkit-scrollbar-track {\n  background: transparent;\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb {\n  background: var(--primary-color);\n\n  border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: var(--accent-color);\n}\n\n/* Firefox */\n#crossword {\n  /* scrollbar-width: thin; */\n  /* scrollbar-color: var(--primary-color) var(--surface-color); */\n}\n\n@media (max-width: 768px) {\n  #crossword-container {\n    flex-direction: column;\n    align-items: center;\n    padding: 20px 0;\n  }\n\n  #crossword {\n    width: 90%;\n    order: 2;\n    padding: 10px;\n  }\n\n  #clues {\n    width: 100%;\n    position: relative;\n    top: 0;\n    left: 0;\n    order: 1;\n    max-height: none;\n  }\n}\n\n.cell {\n  width: 40px;\n  height: 40px;\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* Remove the default border since we handle it in getHighlightedCellBorder */\n  /* border: 1px solid var(--dark-border-color); */\n}\n\n.empty {\n  border: none;\n  background-color: transparent;\n}\n\n.cell input {\n  width: 100%;\n  height: 100%;\n  text-align: center;\n  font-size: 16px;\n  padding: 0;\n  margin: 0;\n  border: none;\n  outline: none;\n  background: transparent;\n  text-transform: uppercase;\n  box-sizing: border-box;\n  border-radius: 0;\n}\n\n.cell:hover {\n  background-color: var(--hover-color, rgba(0, 0, 0, 0.05));\n}\n\n.cell input:focus {\n  background-color: var(--focus-color, rgba(var(--primary-rgb, 46, 204, 113), 0.1));\n}\n\n.cell input.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n.cell input.highlighted-intersection {\n  background-color: var(--intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n.cell .clue-number {\n  position: relative;\n  top: -8px;\n  left: 2px;\n  font-size: var(--clue-number-size, 0.75rem);\n  font-weight: bold;\n  color: var(--text-color);\n  width: 0;\n}\n\n/* #clues h2 {\n  font-size: 24px;\n  margin-bottom: 10px;\n  color: var(--text-color);\n} */\n\n#clue-list {\n  list-style: none;\n  margin-top: 20px;\n  overflow-y: auto;\n  list-style-position: outside;\n}\n\n#clue-list li {\n  margin-bottom: 0px;\n  font-size: 1rem;\n  text-align: left;\n  /* color: #eee; */\n  word-wrap: break-word;\n  cursor: pointer;\n  padding: 4px;\n}\n\n#clue-list li.highlighted {\n  background-color: var(--highlight-color, rgba(255, 255, 0, 0.3));\n  font-size: 1.1rem;\n}\n\n.button-container {\n  display: flex;\n  gap: 1rem;\n  justify-content: center;\n  /* margin-top: 20px; */\n}\n\n#check-button,\n#new-game-button {\n  padding: 8px 20px;\n  font-size: 14px;\n  /* background-color: var(--primary-color); */\n  background: #eee;\n\n  /* color: #fff; */\n  /* border: none; */\n  border-radius: 5px;\n  cursor: pointer;\n}\n\n#check-button:hover,\n#new-game-button:hover {\n  background-color: var(--accent-color);\n}\n\n@media (max-width: 480px) {\n  .cell {\n    width: 100%;\n    height: 100%;\n  }\n\n  .cell input {\n    font-size: 14px;\n  }\n}\n\n.loading-overlay {\n  position: fixed;\n  top: 0;\n  left: 0;\n  right: 0;\n  bottom: 0;\n  background: rgba(255, 255, 255, 0.4);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 100;\n}\n\n.loading-message {\n  text-align: center;\n  padding: 20px;\n  background-color: var(--surface-color, #fff);\n  border-radius: 8px;\n  box-shadow: var(--shadow-sm);\n  border: 1px solid var(--border-color);\n}\n\n:deep(.dark) .loading-overlay {\n  background: rgba(0, 0, 0, 0.4);\n}\n\n:deep(.dark) .cell {\n  border-color: var(--dark-border-color);\n}\n\n:deep(.dark) .cell:hover {\n  background-color: var(--dark-hover-color, rgba(255, 255, 255, 0.1));\n}\n\n:deep(.dark) .cell input {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) .cell input:focus {\n  background-color: var(--dark-focus-color, rgba(var(--dark-primary-rgb, 46, 204, 113), 0.2));\n}\n\n:deep(.dark) .cell input.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n\n:deep(.dark) .cell input.highlighted-intersection {\n  background-color: var(--dark-intersection-highlight-color, rgba(0, 255, 255, 0.3));\n}\n\n:deep(.dark) .cell .clue-number {\n  color: var(--dark-text-color);\n}\n\n/* :deep(.dark) #clues h2 {\n  color: var(--dark-text-color);\n} */\n\n:deep(.dark) #clue-list li {\n  color: var(--dark-text-color);\n}\n\n:deep(.dark) #clue-list li.highlighted {\n  background-color: var(--dark-highlight-color, rgba(255, 255, 0, 0.3));\n}\n</style>"],"names":["GRID_ROWS","GRID_COLS","usePerk","useGamePoints","WORD_COLORS","GRID_CENTER_ROW","Math","floor","GRID_CENTER_COL","grid","ref","placedWords","currentWord","currentDirection","highlightedCells","Set","highlightedIntersections","highlightedClue","cellRefs","reactive","isLoading","currentAttempt","vocabularyStore","useVocabularyStore","isInitialLoad","lastClickedCell","row","col","wordIndex","gridStyle","computed","gridTemplateColumns","gridTemplateRows","gridRows","Array","from","length","_","i","gridCols","getCell","_a","value","getCellWords","cellWords","filter","word","positions","some","pos","JSON","stringify","map","wordNumber","number","direction","getCellColor","color","has","isHighlighted","isIntersectionHighlighted","getHighlightedCellBorder","styles","border","backgroundColor","hasHighlightedHorizontal","hasHighlightedVertical","forEach","borderTop","borderBottom","borderLeft","borderRight","isStartingCell","getWordNumber","find","w","highlightWord","wordObj","clearHighlights","add","clear","normalizeString","str","normalize","replace","toUpperCase","trim","handleInput","event","input","target","parse","dataset","words","isInputPartOfCurrentWord","data","currentInput","currentRow","parseInt","currentCol","prevRow","prevCol","prevInput","focus","select","moveToPreviousInput","nextRow","nextCol","nextInput","moveToNextInput","currentWordObj","checkAnswers","allCorrect","key","correct","style","alert","startGame","canPlaceWord","hasIntersection","currentCell","above","below","isPartOfWord","before","after","left","right","async","visualizePlacement","temp","push","ms","Promise","resolve","setTimeout","sleep","countIntersections","intersections","findAllPossiblePositions","sort","a","b","placeRemainingWords","availableWords","placed","triedIndices","size","randomIndex","random","allPossiblePositions","positionsInDirection","topPositions","slice","min","selectedPosition","clue","splice","generateCrossword","fill","initializeGrid","crosswordDiv","document","getElementById","scrollLeft","scrollWidth","clientWidth","scrollTop","scrollHeight","clientHeight","scrollTo","top","behavior","scrollToGridCenter","firstWord","force","filteredWords","error","handlePerk","perkId","allInputs","Object","values","randomInput","onMounted","selectedWord"],"mappings":"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"}