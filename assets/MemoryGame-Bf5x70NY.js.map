{"version":3,"file":"MemoryGame-Bf5x70NY.js","sources":["../../src/components/game/GameCardFlip.vue","../../src/views/MemoryGame.vue"],"sourcesContent":["<template>\n  <div\n    class=\"card\"\n    :class=\"cardClasses\"\n    :style=\"cardStyles\"\n    @click=\"!disabled && emit('click')\"\n  >\n    <div class=\"card-inner\" :style=\"innerStyles\">\n      <div class=\"card-front\">\n        <slot name=\"front\">\n          <font-awesome-icon :icon=\"['fas', 'question']\" size=\"2x\" />\n        </slot>\n      </div>\n      <div class=\"card-back\">\n        <slot name=\"back\" />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { computed, shallowRef, watch } from 'vue';\nimport { useUIStore } from '@/store/ui';\n\nconst props = defineProps({\n  flipped: {\n    type: Boolean,\n    default: false\n  },\n  matched: {\n    type: Boolean,\n    default: false\n  },\n  disabled: {\n    type: Boolean,\n    default: false\n  }\n});\n\nconst emit = defineEmits(['click']);\n\n// Use shallowRef for better performance on frequently changing props\nconst flippedState = shallowRef(props.flipped);\nconst matchedState = shallowRef(props.matched);\n\n// Cache dark mode state\nconst uiStore = useUIStore();\nconst isDarkMode = shallowRef(uiStore.isDarkMode);\n\n// Watch props efficiently\nwatch(() => props.flipped, (newVal) => {\n  flippedState.value = newVal;\n}, { flush: 'post' });\n\nwatch(() => props.matched, (newVal) => {\n  matchedState.value = newVal;\n}, { flush: 'post' });\n\n// Cache class computation\nconst cardClasses = computed(() => ({\n  flipped: flippedState.value,\n  matched: matchedState.value,\n  dark: isDarkMode.value\n}));\n\n// Cache style computation for transforms\nconst cardStyles = computed(() => ({\n  transform: matchedState.value ? 'scale(0.95)' : undefined,\n  willChange: flippedState.value ? 'transform' : undefined\n}));\n\nconst innerStyles = computed(() => ({\n  transform: flippedState.value ? 'rotateY(180deg)' : undefined\n}));\n</script>\n\n<style scoped>\n.card {\n  aspect-ratio: 3/4;\n  perspective: 1000px;\n  cursor: pointer;\n  user-select: none;\n}\n\n.card.matched {\n  cursor: default;\n}\n\n.card-inner {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transition: transform 0.6s cubic-bezier(0.4, 0, 0.2, 1);\n  transform-style: preserve-3d;\n}\n\n.card-front,\n.card-back {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  backface-visibility: hidden;\n  border-radius: var(--radius-md);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  /* padding: var(--spacing-md); */\n  box-shadow: var(--shadow-sm);\n  transition: all 0.3s ease;\n}\n\n.card-front {\n  background: linear-gradient(135deg, var(--primary-color), var(--secondary-color));\n  color: white;\n  font-size: 1.5rem;\n  font-weight: 600;\n}\n\n.card-back {\n  background-color: var(--surface-color);\n  border: 1px solid var(--border-color);\n  color: var(--text-color);\n  transform: rotateY(180deg) rotate(-12deg);\n  font-size: 0.9rem;\n  text-align: center;\n}\n\n/* Hover effects */\n.card:not(.matched):hover .card-front {\n  box-shadow: var(--shadow-md);\n  transform: translateZ(10px);\n}\n\n/* Dark mode styles */\n.dark .card-back {\n  background-color: var(--dark-surface-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-border-color);\n}\n\n/* Responsive styles */\n@media (max-width: 768px) {\n  .card-front {\n    font-size: 1.25rem;\n  }\n\n  .card-back {\n    font-size: 0.8rem;\n  }\n}\n</style>","<template>\n  <GameContainer\n    title=\"Jogo da Memória\"\n    :gameInstructions=\"gameInstructions\"\n    :loading=\"loading\"\n    :score=\"score\"\n    :availablePerks=\"['hint', 'open_third_card']\"\n    @specialty-change=\"createBoard\"\n    @difficulty-change=\"createBoard\"\n  >\n    <template #game-settings>\n      <div class=\"game-settings\">\n        <h3>Configurações</h3>\n        <div class=\"setting-group\">\n          <label>Número de pares</label>\n          <input type=\"range\" :value=\"pairCount\" min=\"8\" max=\"40\" step=\"4\" @input=\"handlePairCountChange\" />\n          <p class=\"setting-description\">Quantidade de pares de palavras no jogo ({{ pairCount }} pares)</p>\n        </div>\n        <!-- <div class=\"setting-group\">\n          <label>Tamanho das cartas</label>\n          <input type=\"range\" :value=\"cardSize\" min=\"100\" max=\"200\" step=\"20\" @input=\"handleCardSizeChange\" />\n          <p class=\"setting-description\">Ajuste o tamanho das cartas</p>\n        </div> -->\n      </div>\n    </template>\n\n    <div class=\"game-content\">\n      <p id=\"definition\">\n        {{\n          currentDefinition\n            ? currentDefinition.clue\n            : \"Todas as palavras foram encontradas!\"\n        }}\n      </p>\n\n      <div id=\"game-board\">\n        <GameCardFlip\n          v-for=\"(card, index) in gameCards\"\n          :key=\"index\"\n          :flipped=\"card.flipped\"\n          :matched=\"card.matched\"\n          :disabled=\"count >= maxOpenCards\"\n          :cardSize=\"cardSize\"\n          @click=\"flipCard(index)\"\n        >\n          <template #back>{{ card.word }}</template>\n        </GameCardFlip>\n      </div>\n    </div>\n  </GameContainer>\n</template>\n\n<script setup>\nimport { ref, computed, onMounted } from \"vue\";\nimport GameContainer from \"@/components/game/GameContainer.vue\";\nimport GameCardFlip from \"@/components/game/GameCardFlip.vue\";\nimport { useGamePoints } from '@/composables/useGamePoints';\nimport { useVocabularyStore } from \"@/store/vocabulary\";\nimport { useGameState } from '@/composables/useGameState';\n\nconst gameInstructions = `Encontre os pares de palavras correspondentes!\n- Clique em uma carta para revelar a palavra\n- Combine a palavra com sua definição mostrada acima\n- Ganhe 2 pontos por cada par encontrado\n- Ganhe 10 pontos por completar o jogo\n- Ganhe 15 pontos de bônus por terminar sem erros\n- Use o perk 'hint' (5 pts) para revelar um par de cartas\n- O perk 'open_third_card' (6 pts) permite abrir três cartas simultaneamente`;\n\nconst loading = ref(false);\nconst vocabularyStore = useVocabularyStore();\nconst { POINTS_CONFIG, awardPoints, usePerk } = useGamePoints();\nconst { startGame: initGameState, endGame, resetGame } = useGameState();\n\nconst score = ref(0);\nconst attempts = ref(0);\nconst pointsEarned = ref(0);\nconst gameCards = ref([]);\nconst currentDefinition = ref(null);\nconst gameWords = ref([]);\nconst availableDefinitions = ref([]);\nconst count = ref(0);\nconst firstCardIndex = ref(null);\nconst secondCardIndex = ref(null);\nconst thirdCardIndex = ref(null);\nconst matchedCards = ref([]);\nconst maxOpenCards = ref(2);\nconst pairCount = ref(8);\nconst cardSize = ref(140);\n\nfunction handlePairCountChange(e) {\n  pairCount.value = parseInt(e.target.value);\n  createBoard();\n}\n\nfunction createBoard() {\n  resetGame();\n  score.value = 0;\n  attempts.value = 0;\n  pointsEarned.value = 0;\n  gameCards.value = [];\n  matchedCards.value = [];\n  gameWords.value = [];\n  maxOpenCards.value = 2;\n\n  let filteredWords = vocabularyStore.words.filter((word) => word.isActive);\n  if (filteredWords.length < 2) {\n    alert(\n      \"Não há palavras suficientes para iniciar o jogo. Por favor, ajuste os filtros.\"\n    );\n    return;\n  }\n\n  filteredWords.sort(() => Math.random() - 0.5);\n  gameWords.value = filteredWords.slice(0, pairCount.value);\n\n  availableDefinitions.value = [...gameWords.value];\n  selectNextDefinition();\n\n  const cards = [...gameWords.value, ...gameWords.value].map((wordObj) => ({\n    word: wordObj.word,\n    flipped: false,\n    matched: false,\n  }));\n  cards.sort(() => Math.random() - 0.5);\n  gameCards.value = cards;\n}\n\nfunction selectNextDefinition() {\n  if (availableDefinitions.value.length === 0) {\n    currentDefinition.value = null;\n  } else {\n    availableDefinitions.value.sort(() => Math.random() - 0.5);\n    currentDefinition.value = availableDefinitions.value.pop();\n  }\n}\n\nfunction flipCard(index) {\n  const card = gameCards.value[index];\n  if (card.flipped || card.matched) return;\n\n  card.flipped = true;\n  attempts.value++;\n\n  if (count.value === 0) {\n    firstCardIndex.value = index;\n    count.value = 1;\n  } else if (count.value === 1) {\n    secondCardIndex.value = index;\n    count.value = 2;\n    if (maxOpenCards.value === 2) {\n      checkMatch();\n    }\n  } else if (count.value === 2 && maxOpenCards.value === 3) {\n    thirdCardIndex.value = index;\n    count.value = 3;\n    checkMatch();\n  }\n}\n\nfunction checkMatch() {\n  const firstCard = gameCards.value[firstCardIndex.value];\n  const secondCard = gameCards.value[secondCardIndex.value];\n  \n  if (maxOpenCards.value === 2) {\n    if (\n      firstCard.word === currentDefinition.value.word &&\n      secondCard.word === currentDefinition.value.word\n    ) {\n      firstCard.matched = true;\n      secondCard.matched = true;\n      matchedCards.value.push(firstCard, secondCard);\n      resetGuesses();\n      if (matchedCards.value.length === gameCards.value.length) {\n        handleGameCompletion();\n      } else {\n        setTimeout(() => {\n          selectNextDefinition();\n        }, 500);\n      }\n    } else {\n      setTimeout(() => {\n        unflipCards();\n      }, 1000);\n    }\n  } else {\n    const thirdCard = gameCards.value[thirdCardIndex.value];\n    const word = currentDefinition.value.word;\n    let matched = 0;\n    if (firstCard.word === word) matched++;\n    if (secondCard.word === word) matched++;\n    if (thirdCard.word === word) matched++;\n    if (matched >= 2) {\n      [firstCard, secondCard, thirdCard].forEach(card => {\n        if (card.word === word) card.matched = true;\n      });\n      matchedCards.value.push(...[firstCard, secondCard, thirdCard].filter(card => card.word === word));\n      resetGuesses();\n      maxOpenCards.value = 2;\n      if (matchedCards.value.length === gameCards.value.length) {\n        handleGameCompletion();\n      } else {\n        setTimeout(() => {\n          selectNextDefinition();\n        }, 500);\n      }\n    } else {\n      setTimeout(() => {\n        unflipCards();\n        maxOpenCards.value = 2;\n      }, 1000);\n    }\n  }\n}\n\nfunction unflipCards() {\n  if (firstCardIndex.value !== null) gameCards.value[firstCardIndex.value].flipped = false;\n  if (secondCardIndex.value !== null) gameCards.value[secondCardIndex.value].flipped = false;\n  if (thirdCardIndex.value !== null) gameCards.value[thirdCardIndex.value].flipped = false;\n  resetGuesses();\n}\n\nfunction resetGuesses() {\n  count.value = 0;\n  firstCardIndex.value = null;\n  secondCardIndex.value = null;\n  thirdCardIndex.value = null;\n}\n\nasync function handlePerk(perkId) {\n  const success = await usePerk(perkId);\n  if (!success) return;\n\n  if (perkId === 'hint' && currentDefinition.value) {\n    // Find unmatched cards for the current word and reveal them temporarily\n    const word = currentDefinition.value.word;\n    const indices = gameCards.value\n      .map((card, idx) => ({ card, idx }))\n      .filter(({ card }) => card.word === word && !card.matched && !card.flipped)\n      .map(({ idx }) => idx);\n\n    if (indices.length >= 2) {\n      gameCards.value[indices[0]].flipped = true;\n      gameCards.value[indices[1]].flipped = true;\n      \n      // After 2 seconds, check if they match or flip them back\n      setTimeout(() => {\n        if (!gameCards.value[indices[0]].matched) {\n          checkMatch();\n        }\n      }, 2000);\n    }\n  } else if (perkId === 'open_third_card') {\n    // Allow opening three cards at once for 30 seconds\n    maxOpenCards.value = 3;\n    setTimeout(() => {\n      maxOpenCards.value = 2;\n      // If three cards are open, flip them back\n      if (count.value === 3) {\n        unflipCards();\n      }\n    }, 30000);\n  } else if (perkId === 'extra_time') {\n    // Add 30 seconds to the timer if it exists\n    if (typeof timeLeft !== 'undefined' && timeLeft) {\n      timeLeft.value += 30;\n    }\n  }\n}\n\nfunction calculateGamePoints() {\n  const basePoints = (matchedCards.value.length / 2) * POINTS_CONFIG.WORD_FOUND;\n  const isPerfect = attempts.value === matchedCards.value.length;\n  return basePoints + POINTS_CONFIG.GAME_COMPLETION + (isPerfect ? POINTS_CONFIG.PERFECT_SCORE : 0);\n}\n\nasync function handleGameCompletion() {\n  endGame();\n  const points = calculateGamePoints();\n  await awardPoints(points);\n  pointsEarned.value = points;\n  setTimeout(() => {\n    alert(\n      `Parabéns! Você encontrou todos os pares em ${attempts.value} tentativas.\\nPontos ganhos: ${points}`\n    );\n    createBoard();\n  }, 500);\n}\n\nonMounted(() => {\n  createBoard();\n});\n</script>\n\n<style scoped>\n.game-content {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n}\n\n.game-settings {\n  min-width: 300px;\n  padding: var(--spacing-md);\n}\n\n.game-settings h3 {\n  margin-bottom: var(--spacing-md);\n  color: var(--text-color);\n}\n\n.setting-group {\n  margin-bottom: var(--spacing-md);\n}\n\n.setting-group label {\n  display: block;\n  margin-bottom: var(--spacing-sm);\n  color: var(--text-secondary);\n  font-weight: 500;\n}\n\n.setting-description {\n  font-size: 0.9rem;\n  color: var(--text-secondary);\n  margin-top: var(--spacing-xs);\n}\n\n#definition {\n  font-size: 1.25rem;\n  margin: var(--spacing-lg) 0;\n  padding: var(--spacing-md);\n  background-color: var(--surface-color);\n  border-radius: var(--radius-md);\n  box-shadow: var(--shadow-sm);\n  color: var(--text-color);\n  line-height: 1.6;\n  border: 1px solid var(--border-color);\n  max-width: 800px;\n  margin-left: auto;\n  margin-right: auto;\n  text-align: center;\n}\n\n#game-board {\n  display: grid;\n  grid-template-columns: repeat(8, 1fr);\n\n  gap: var(--spacing-md);\n  padding: var(--spacing-md);\n  margin: 0 auto;\n  width: 100%;\n  max-width: 900px;\n  perspective: 1000px;\n  justify-content: center;\n}\n\n@media (max-width: 768px) {\n  #game-board {\n    grid-template-columns: repeat(4, 1fr);\n  }\n}\n\n:deep(.dark) #definition {\n  background-color: var(--dark-surface-color);\n  color: var(--dark-text-color);\n  border-color: var(--dark-border-color);\n}\n\n@media (max-width: 768px) {\n  .game-content {\n    padding: var(--spacing-sm);\n  }\n\n  #game-board {\n    gap: var(--spacing-sm);\n    padding: var(--spacing-md);\n    width: 100%;\n  }\n\n  #definition {\n    font-size: 1.1rem;\n    margin: var(--spacing-md) var(--spacing-sm);\n    padding: var(--spacing-sm);\n  }\n}\n</style>\n"],"names":["props","__props","emit","__emit","flippedState","shallowRef","flipped","matchedState","matched","uiStore","useUIStore","isDarkMode","watch","newVal","value","flush","cardClasses","computed","dark","cardStyles","transform","willChange","innerStyles","loading","ref","vocabularyStore","useVocabularyStore","POINTS_CONFIG","awardPoints","useGamePoints","endGame","resetGame","useGameState","score","attempts","pointsEarned","gameCards","currentDefinition","gameWords","availableDefinitions","count","firstCardIndex","secondCardIndex","thirdCardIndex","matchedCards","maxOpenCards","pairCount","cardSize","handlePairCountChange","e","parseInt","target","createBoard","filteredWords","words","filter","word","isActive","length","alert","sort","Math","random","slice","selectNextDefinition","cards","map","wordObj","pop","checkMatch","firstCard","secondCard","push","resetGuesses","handleGameCompletion","setTimeout","unflipCards","thirdCard","forEach","card","async","points","basePoints","WORD_FOUND","isPerfect","GAME_COMPLETION","PERFECT_SCORE","calculateGamePoints","onMounted","index"],"mappings":"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"}